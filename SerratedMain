--[[
    Modern Command Menu Script v5.2 - ULTRA FIXED EDITION
    
    ✓ FIXED: Overhead cards now show for ALL script users (including yourself)
    ✓ NEW: Avatar preview in overhead cards
    ✓ FIXED: Superman fly animations (all directions + backward)
    ✓ Auto-reexecution on rejoin/server hop
    ✓ Improved draggable button styling
    ✓ Professional UI/UX
    
    KEY FIXES:
    - Uses Player Attributes for detection
    - Cards visible to everyone using the script
    - Avatar thumbnails in overhead
    - Full directional animations for Superman
]]

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local StarterGui = game:GetService("StarterGui")
local TeleportService = game:GetService("TeleportService")
local VirtualUser = game:GetService("VirtualUser")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local mouse = player:GetMouse()

-- Auto-reexecution setup
local SCRIPT_URL = "https://raw.githubusercontent.com/Zay-Aka-Yuji/Serrated/refs/heads/main/SerratedMain"
local AUTO_REEXEC_FLAG = "SERRATED_AUTO_REEXEC"

-- Check if this is an auto-reexecution
local isAutoReexec = false
if _G[AUTO_REEXEC_FLAG] then
    isAutoReexec = true
    _G[AUTO_REEXEC_FLAG] = nil
end

-- Detect Executor
local function getExecutor()
    if identifyexecutor then
        return identifyexecutor()
    elseif KRNL_LOADED then
        return "KRNL"
    elseif syn then
        return "Synapse X"
    elseif SENTINEL_LOADED then
        return "Sentinel"
    elseif getexecutorname then
        return getexecutorname()
    else
        return "Unknown"
    end
end

-- Detect Device
local function getDevice()
    if UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled then
        return "Mobile"
    elseif UserInputService.KeyboardEnabled and not UserInputService.TouchEnabled then
        return "PC"
    elseif UserInputService.GamepadEnabled then
        return "Console"
    else
        return "PC"
    end
end

local EXECUTOR = getExecutor()
local DEVICE = getDevice()

-- Configuration
local CONFIG = {
    Colors = {
        Primary = Color3.fromRGB(138, 43, 226),
        Secondary = Color3.fromRGB(75, 0, 130),
        Background = Color3.fromRGB(20, 20, 20),
        BackgroundTransparent = Color3.fromRGB(15, 15, 15),
        Text = Color3.fromRGB(255, 255, 255),
        TextSecondary = Color3.fromRGB(200, 200, 200),
        Success = Color3.fromRGB(100, 200, 100),
        Error = Color3.fromRGB(220, 80, 80),
        Suggestion = Color3.fromRGB(150, 150, 150)
    },
    Animations = {
        Speed = 0.4,
        EasingStyle = Enum.EasingStyle.Quint,
        EasingDirection = Enum.EasingDirection.Out
    },
    ToggleKey = Enum.KeyCode.RightControl,
    CommandPrefix = "!",
    DebugMode = false
}

-- Command List for Autocomplete
local commandList = {
    {cmd = "!fly", desc = "Enable admin fly", requiresUsername = false},
    {cmd = "!unfly", desc = "Disable fly", requiresUsername = false},
    {cmd = "!flyspeed", desc = "Set fly speed", requiresUsername = false, requiresNumber = true},
    {cmd = "!rsfly", desc = "Reset fly speed", requiresUsername = false},
    {cmd = "!smfly", desc = "Superman fly", requiresUsername = false},
    {cmd = "!superman", desc = "Superman fly", requiresUsername = false},
    {cmd = "!unsmfly", desc = "Disable superman", requiresUsername = false},
    {cmd = "!unsuperman", desc = "Disable superman", requiresUsername = false},
    {cmd = "!smspeed", desc = "Set superman speed", requiresUsername = false, requiresNumber = true},
    {cmd = "!rssm", desc = "Reset superman speed", requiresUsername = false},
    {cmd = "!noclip", desc = "Walk through walls", requiresUsername = false},
    {cmd = "!clip", desc = "Walk through walls", requiresUsername = false},
    {cmd = "!unnoclip", desc = "Disable noclip", requiresUsername = false},
    {cmd = "!unclip", desc = "Disable noclip", requiresUsername = false},
    {cmd = "!float", desc = "Float mode", requiresUsername = false},
    {cmd = "!unfloat", desc = "Disable float", requiresUsername = false},
    {cmd = "!infj", desc = "Infinite jump", requiresUsername = false},
    {cmd = "!infinitejump", desc = "Infinite jump", requiresUsername = false},
    {cmd = "!uninfj", desc = "Disable infinite jump", requiresUsername = false},
    {cmd = "!uninfinitejump", desc = "Disable infinite jump", requiresUsername = false},
    {cmd = "!tp", desc = "Teleport to player", requiresUsername = true},
    {cmd = "!goto", desc = "Teleport to player", requiresUsername = true},
    {cmd = "!tptool", desc = "Click teleport tool", requiresUsername = false},
    {cmd = "!bring", desc = "Bring player to you", requiresUsername = true},
    {cmd = "!ws", desc = "Set walkspeed", requiresUsername = false, requiresNumber = true},
    {cmd = "!walkspeed", desc = "Set walkspeed", requiresUsername = false, requiresNumber = true},
    {cmd = "!resetws", desc = "Reset walkspeed", requiresUsername = false},
    {cmd = "!jp", desc = "Set jump power", requiresUsername = false, requiresNumber = true},
    {cmd = "!jumppower", desc = "Set jump power", requiresUsername = false, requiresNumber = true},
    {cmd = "!resetjp", desc = "Reset jump power", requiresUsername = false},
    {cmd = "!gravity", desc = "Set gravity", requiresUsername = false, requiresNumber = true},
    {cmd = "!resetgravity", desc = "Reset gravity", requiresUsername = false},
    {cmd = "!char", desc = "Load player avatar", requiresUsername = true},
    {cmd = "!invisible", desc = "Become invisible", requiresUsername = false},
    {cmd = "!visible", desc = "Become visible", requiresUsername = false},
    {cmd = "!cb", desc = "Toggle chat bypass", requiresUsername = false},
    {cmd = "!chatbypass", desc = "Toggle chat bypass", requiresUsername = false},
    {cmd = "!antiafk", desc = "Toggle anti-AFK", requiresUsername = false},
    {cmd = "!antiidle", desc = "Toggle anti-AFK", requiresUsername = false},
    {cmd = "!antivcban", desc = "Toggle anti-VC-ban", requiresUsername = false},
    {cmd = "!antivcb", desc = "Toggle anti-VC-ban", requiresUsername = false},
    {cmd = "!novcb", desc = "Toggle anti-VC-ban", requiresUsername = false},
    {cmd = "!rejoin", desc = "Rejoin server", requiresUsername = false},
    {cmd = "!rj", desc = "Rejoin server", requiresUsername = false},
    {cmd = "!serverhop", desc = "Server hop", requiresUsername = false},
    {cmd = "!shop", desc = "Server hop", requiresUsername = false},
    {cmd = "!join", desc = "Join player's server", requiresUsername = true},
    {cmd = "!spin", desc = "Spin character", requiresUsername = false},
    {cmd = "!unspin", desc = "Stop spinning", requiresUsername = false},
    {cmd = "!spinspeed", desc = "Set spin speed", requiresUsername = false, requiresNumber = true},
    {cmd = "!update", desc = "Update script", requiresUsername = false},
    {cmd = "!updt", desc = "Update script", requiresUsername = false},
    {cmd = "!unexecute", desc = "Remove script", requiresUsername = false},
    {cmd = "!help", desc = "Show commands", requiresUsername = false},
    {cmd = "!users", desc = "List script users", requiresUsername = false},
    {cmd = "!debug", desc = "Debug mode & info", requiresUsername = false},
    {cmd = "!refresh", desc = "Refresh overhead cards", requiresUsername = false}
}

-- Command State Management
local commandStates = {
    flying = false,
    noclip = false,
    float = false,
    infiniteJump = false,
    supermanFly = false,
    chatBypass = false,
    antiAfk = false,
    antiVcBan = false,
    spinning = false,
    invisible = false,
    flySpeed = 50,
    supermanSpeed = 3,
    spinSpeed = 10,
    originalWalkSpeed = 16,
    originalJumpPower = 50,
    originalGravity = 196.2
}

local activeConnections = {}
local scriptUsers = {}
local scriptActive = true
local allUserCards = {}

-- Chat Bypass Characters
local bypassChars = {
    ["a"] = "а", ["e"] = "е", ["o"] = "о", ["p"] = "р", ["c"] = "с",
    ["y"] = "у", ["x"] = "х", ["i"] = "і", ["s"] = "ѕ", ["h"] = "һ",
    ["A"] = "А", ["B"] = "В", ["C"] = "С", ["E"] = "Е", ["H"] = "Н",
    ["I"] = "І", ["K"] = "К", ["M"] = "М", ["O"] = "О", ["P"] = "Р",
    ["S"] = "Ѕ", ["T"] = "Т", ["X"] = "Х", ["Y"] = "У"
}

-- Debug Logging
local function debugLog(category, message)
    if not CONFIG.DebugMode then return end
    print(string.format("[SERRATED-%s] %s", category, message))
end

-- ═══════════════════════════════════════════════════════════
-- FIXED: Player Attribute System (Replicates Across Clients!)
-- ═══════════════════════════════════════════════════════════

local ATTRIBUTE_NAME = "SerratedUser"

local function broadcastPresence()
    if not character or not character:FindFirstChild("HumanoidRootPart") then 
        debugLog("BROADCAST", "No valid character")
        return 
    end
    
    local attributeValue = EXECUTOR .. "|" .. DEVICE
    player:SetAttribute(ATTRIBUTE_NAME, attributeValue)
    debugLog("BROADCAST", "Set attribute: " .. attributeValue)
end

local function isScriptUser(targetPlayer)
    local result = targetPlayer:GetAttribute(ATTRIBUTE_NAME) ~= nil
    debugLog("CHECK", targetPlayer.Name .. " is script user: " .. tostring(result))
    return result
end

local function getPlayerInfo(targetPlayer)
    local attributeValue = targetPlayer:GetAttribute(ATTRIBUTE_NAME)
    if attributeValue and attributeValue ~= "" then
        local parts = {}
        for part in attributeValue:gmatch("[^|]+") do
            table.insert(parts, part)
        end
        return {
            executor = parts[1] or "Unknown",
            device = parts[2] or "Unknown"
        }
    end
    return {executor = "Unknown", device = "Unknown"}
end

-- UI Creation
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "CommandMenuGui"
screenGui.ResetOnSpawn = false
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.Parent = playerGui

-- Utility Functions
local function createGradient(parent, rotation)
    local gradient = Instance.new("UIGradient")
    gradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, CONFIG.Colors.Secondary),
        ColorSequenceKeypoint.new(1, CONFIG.Colors.Primary)
    }
    gradient.Rotation = rotation or 45
    gradient.Parent = parent
    return gradient
end

local function createCorner(parent, radius)
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, radius or 12)
    corner.Parent = parent
    return corner
end

local function createStroke(parent, thickness, color)
    local stroke = Instance.new("UIStroke")
    stroke.Thickness = thickness or 2
    stroke.Color = color or CONFIG.Colors.Primary
    stroke.Transparency = 0.3
    stroke.Parent = parent
    return stroke
end

local function smoothTween(instance, properties, duration, callback)
    duration = duration or CONFIG.Animations.Speed
    local tweenInfo = TweenInfo.new(
        duration,
        CONFIG.Animations.EasingStyle,
        CONFIG.Animations.EasingDirection
    )
    
    local tween = TweenService:Create(instance, tweenInfo, properties)
    tween:Play()
    
    if callback then
        tween.Completed:Connect(callback)
    end
    
    return tween
end

-- Notification System
local notificationQueue = {}
local notificationActive = false

local function showNotification(message, notifType)
    table.insert(notificationQueue, {message = message, type = notifType or "info"})
    
    if not notificationActive then
        notificationActive = true
        
        local function processQueue()
            if #notificationQueue == 0 then
                notificationActive = false
                return
            end
            
            local data = table.remove(notificationQueue, 1)
            
            local notif = Instance.new("Frame")
            notif.Size = UDim2.new(0, 400, 0, 80)
            notif.Position = UDim2.new(1, -420, 0, 100)
            notif.BackgroundColor3 = CONFIG.Colors.BackgroundTransparent
            notif.BorderSizePixel = 0
            notif.Parent = screenGui
            
            createCorner(notif, 16)
            
            local stroke = createStroke(notif, 2, data.type == "error" and CONFIG.Colors.Error or CONFIG.Colors.Primary)
            stroke.Transparency = 0
            
            local iconContainer = Instance.new("Frame")
            iconContainer.Size = UDim2.new(0, 60, 1, 0)
            iconContainer.BackgroundColor3 = data.type == "error" and CONFIG.Colors.Error or CONFIG.Colors.Primary
            iconContainer.BorderSizePixel = 0
            iconContainer.Parent = notif
            
            createCorner(iconContainer, 16)
            
            local logo = Instance.new("TextLabel")
            logo.Size = UDim2.new(1, 0, 1, 0)
            logo.BackgroundTransparency = 1
            logo.Text = "$"
            logo.TextColor3 = CONFIG.Colors.Text
            logo.TextSize = 36
            logo.Font = Enum.Font.GothamBold
            logo.Parent = iconContainer
            
            local messageLabel = Instance.new("TextLabel")
            messageLabel.Size = UDim2.new(1, -80, 1, -20)
            messageLabel.Position = UDim2.new(0, 70, 0, 10)
            messageLabel.BackgroundTransparency = 1
            messageLabel.Text = data.message
            messageLabel.TextColor3 = CONFIG.Colors.Text
            messageLabel.TextSize = 16
            messageLabel.Font = Enum.Font.GothamMedium
            messageLabel.TextWrapped = true
            messageLabel.TextXAlignment = Enum.TextXAlignment.Left
            messageLabel.Parent = notif
            
            smoothTween(notif, {Position = UDim2.new(1, -420, 0, 100)}, 0.5)
            
            wait(3)
            
            smoothTween(notif, {Position = UDim2.new(1, 50, 0, 100)}, 0.5, function()
                notif:Destroy()
                processQueue()
            end)
        end
        
        processQueue()
    end
end

-- User Card Creation (WITH AVATAR PREVIEW!)
local function createUserCard(targetPlayer)
    debugLog("CARD", "Creating card for: " .. targetPlayer.Name)
    
    -- DON'T SKIP SELF - This was the bug!
    if not isScriptUser(targetPlayer) then 
        debugLog("CARD", targetPlayer.Name .. " is NOT a script user")
        return 
    end
    
    local targetCharacter = targetPlayer.Character
    if not targetCharacter then
        debugLog("CARD", "Waiting for character...")
        targetCharacter = targetPlayer.CharacterAdded:Wait()
        wait(1)
    end
    
    local head = targetCharacter:WaitForChild("Head", 5)
    if not head then 
        debugLog("CARD", "No head found")
        return 
    end
    
    local existingCard = head:FindFirstChild("UserCard")
    if existingCard then 
        existingCard:Destroy()
        wait(0.1)
    end
    
    local playerInfo = getPlayerInfo(targetPlayer)
    
    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Name = "UserCard"
    billboardGui.Size = UDim2.new(0, 320, 0, 100)
    billboardGui.StudsOffset = Vector3.new(0, 3.5, 0)
    billboardGui.AlwaysOnTop = true
    billboardGui.Parent = head
    
    table.insert(allUserCards, billboardGui)
    
    local card = Instance.new("Frame")
    card.Size = UDim2.new(1, 0, 1, 0)
    card.BackgroundColor3 = CONFIG.Colors.Background
    card.BorderSizePixel = 0
    card.BackgroundTransparency = 0.15
    card.Parent = billboardGui
    
    createCorner(card, 14)
    createStroke(card, 2)
    
    local glow = Instance.new("Frame")
    glow.Size = UDim2.new(1, 4, 1, 4)
    glow.Position = UDim2.new(0, -2, 0, -2)
    glow.BackgroundColor3 = CONFIG.Colors.Primary
    glow.BackgroundTransparency = 0.7
    glow.BorderSizePixel = 0
    glow.ZIndex = 0
    glow.Parent = card
    
    createCorner(glow, 14)
    
    -- AVATAR PREVIEW
    local avatarFrame = Instance.new("Frame")
    avatarFrame.Size = UDim2.new(0, 80, 0, 80)
    avatarFrame.Position = UDim2.new(0, 8, 0, 10)
    avatarFrame.BackgroundColor3 = CONFIG.Colors.BackgroundTransparent
    avatarFrame.BorderSizePixel = 0
    avatarFrame.Parent = card
    
    createCorner(avatarFrame, 12)
    createStroke(avatarFrame, 2)
    
    local avatarImage = Instance.new("ImageLabel")
    avatarImage.Size = UDim2.new(1, -4, 1, -4)
    avatarImage.Position = UDim2.new(0, 2, 0, 2)
    avatarImage.BackgroundTransparency = 1
    avatarImage.Image = Players:GetUserThumbnailAsync(targetPlayer.UserId, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size150x150)
    avatarImage.Parent = avatarFrame
    
    createCorner(avatarImage, 10)
    
    local logo = Instance.new("TextLabel")
    logo.Size = UDim2.new(0, 40, 0, 40)
    logo.Position = UDim2.new(0, 5, 0, 5)
    logo.BackgroundColor3 = CONFIG.Colors.Primary
    logo.BackgroundTransparency = 0.3
    logo.Text = "$"
    logo.TextColor3 = CONFIG.Colors.Text
    logo.TextSize = 28
    logo.Font = Enum.Font.GothamBold
    logo.ZIndex = 2
    logo.Parent = avatarFrame
    
    createCorner(logo, 8)
    
    local typingText = Instance.new("TextLabel")
    typingText.Size = UDim2.new(1, -108, 0, 25)
    typingText.Position = UDim2.new(0, 98, 0, 8)
    typingText.BackgroundTransparency = 1
    typingText.Text = ""
    typingText.TextColor3 = CONFIG.Colors.Text
    typingText.TextSize = 18
    typingText.Font = Enum.Font.GothamBold
    typingText.TextXAlignment = Enum.TextXAlignment.Left
    typingText.Parent = card
    
    local infoText = Instance.new("TextLabel")
    infoText.Size = UDim2.new(1, -108, 0, 20)
    infoText.Position = UDim2.new(0, 98, 0, 35)
    infoText.BackgroundTransparency = 1
    infoText.Text = playerInfo.executor .. " | " .. playerInfo.device
    infoText.TextColor3 = CONFIG.Colors.TextSecondary
    infoText.TextSize = 13
    infoText.Font = Enum.Font.GothamMedium
    infoText.TextXAlignment = Enum.TextXAlignment.Left
    infoText.Parent = card
    
    local usernameText = Instance.new("TextLabel")
    usernameText.Size = UDim2.new(1, -108, 0, 18)
    usernameText.Position = UDim2.new(0, 98, 0, 55)
    usernameText.BackgroundTransparency = 1
    usernameText.Text = "@" .. targetPlayer.Name
    usernameText.TextColor3 = CONFIG.Colors.Primary
    usernameText.TextSize = 14
    usernameText.Font = Enum.Font.GothamBold
    usernameText.TextXAlignment = Enum.TextXAlignment.Left
    usernameText.TextTruncate = Enum.TextTruncate.AtEnd
    usernameText.Parent = card
    
    local fullText = "$errated User"
    spawn(function()
        while typingText and typingText.Parent and scriptActive do
            for i = 1, #fullText do
                if not typingText or not typingText.Parent or not scriptActive then break end
                typingText.Text = fullText:sub(1, i) .. "|"
                wait(0.08)
            end
            
            for i = 1, 6 do
                if not typingText or not typingText.Parent or not scriptActive then break end
                typingText.Text = fullText .. (i % 2 == 0 and "|" or "")
                wait(0.5)
            end
            
            wait(0.5)
        end
    end)
    
    spawn(function()
        while glow and glow.Parent and scriptActive do
            smoothTween(glow, {BackgroundTransparency = 0.9}, 1)
            wait(1)
            if not scriptActive then break end
            smoothTween(glow, {BackgroundTransparency = 0.7}, 1)
            wait(1)
        end
    end)
    
    card.Size = UDim2.new(0, 0, 0, 0)
    card.Position = UDim2.new(0.5, 0, 0.5, 0)
    card.AnchorPoint = Vector2.new(0.5, 0.5)
    
    smoothTween(card, {
        Size = UDim2.new(1, 0, 1, 0),
        Position = UDim2.new(0.5, 0, 0.5, 0)
    }, 0.6)
    
    debugLog("CARD", "✓ Card created for " .. targetPlayer.Name)
end

-- Monitoring System
local function monitorScriptUsers()
    debugLog("MONITOR", "Starting monitoring system...")
    
    local function safeCreateCard(targetPlayer)
        local attempts = 0
        while attempts < 3 and scriptActive do
            attempts = attempts + 1
            local success = pcall(function()
                createUserCard(targetPlayer)
            end)
            if success then return true end
            wait(0.5)
        end
        return false
    end
    
    -- Create cards for ALL players including self
    for _, targetPlayer in ipairs(Players:GetPlayers()) do
        if isScriptUser(targetPlayer) and targetPlayer.Character then
            safeCreateCard(targetPlayer)
        end
        
        targetPlayer:GetAttributeChangedSignal(ATTRIBUTE_NAME):Connect(function()
            if not scriptActive then return end
            debugLog("MONITOR", "Attribute changed for " .. targetPlayer.Name)
            
            if isScriptUser(targetPlayer) then
                if targetPlayer.Character and targetPlayer.Character:FindFirstChild("Head") then
                    safeCreateCard(targetPlayer)
                end
            else
                if targetPlayer.Character and targetPlayer.Character:FindFirstChild("Head") then
                    local card = targetPlayer.Character.Head:FindFirstChild("UserCard")
                    if card then card:Destroy() end
                end
            end
        end)
        
        targetPlayer.CharacterAdded:Connect(function()
            if not scriptActive or not isScriptUser(targetPlayer) then return end
            wait(1.5)
            safeCreateCard(targetPlayer)
        end)
    end
    
    Players.PlayerAdded:Connect(function(newPlayer)
        if not scriptActive then return end
        
        newPlayer:GetAttributeChangedSignal(ATTRIBUTE_NAME):Connect(function()
            if not scriptActive then return end
            if isScriptUser(newPlayer) and newPlayer.Character then
                safeCreateCard(newPlayer)
            end
        end)
        
        newPlayer.CharacterAdded:Connect(function()
            if not scriptActive or not isScriptUser(newPlayer) then return end
            wait(1.5)
            safeCreateCard(newPlayer)
        end)
    end)
    
    local lastCheck = tick()
    RunService.Heartbeat:Connect(function()
        if not scriptActive or tick() - lastCheck < 3 then return end
        lastCheck = tick()
        
        for _, targetPlayer in ipairs(Players:GetPlayers()) do
            local shouldHaveCard = isScriptUser(targetPlayer)
            local hasCard = targetPlayer.Character 
                and targetPlayer.Character:FindFirstChild("Head") 
                and targetPlayer.Character.Head:FindFirstChild("UserCard")
            
            if shouldHaveCard and not hasCard then
                if targetPlayer.Character and targetPlayer.Character:FindFirstChild("Head") then
                    safeCreateCard(targetPlayer)
                end
            elseif not shouldHaveCard and hasCard then
                hasCard:Destroy()
            end
        end
    end)
    
    debugLog("MONITOR", "Monitoring active!")
end

-- Broadcast continuously
spawn(function()
    while scriptActive do
        broadcastPresence()
        wait(5)
    end
end)

-- FPS Counter
local fps = 0
local lastUpdate = tick()
RunService.RenderStepped:Connect(function()
    if not scriptActive then return end
    local now = tick()
    fps = math.floor(1 / (now - lastUpdate))
    lastUpdate = now
end)

-- Toggle Button
local toggleButton = Instance.new("TextButton")
toggleButton.Size = UDim2.new(0, 220, 0, 70)
toggleButton.Position = UDim2.new(1, -240, 1, -90)
toggleButton.BackgroundColor3 = CONFIG.Colors.Background
toggleButton.BorderSizePixel = 0
toggleButton.Text = ""
toggleButton.Active = true
toggleButton.Draggable = true
toggleButton.Parent = screenGui

createCorner(toggleButton, 14)
createStroke(toggleButton, 2).Transparency = 0
createGradient(toggleButton, 135)

local buttonGlow = Instance.new("Frame")
buttonGlow.Size = UDim2.new(1, 4, 1, 4)
buttonGlow.Position = UDim2.new(0, -2, 0, -2)
buttonGlow.BackgroundColor3 = CONFIG.Colors.Primary
buttonGlow.BackgroundTransparency = 0.7
buttonGlow.BorderSizePixel = 0
buttonGlow.ZIndex = 0
buttonGlow.Parent = toggleButton
createCorner(buttonGlow, 14)

spawn(function()
    while scriptActive do
        smoothTween(buttonGlow, {BackgroundTransparency = 0.9}, 1)
        wait(1)
        smoothTween(buttonGlow, {BackgroundTransparency = 0.7}, 1)
        wait(1)
    end
end)

local buttonLogo = Instance.new("TextLabel")
buttonLogo.Size = UDim2.new(0, 50, 1, 0)
buttonLogo.Position = UDim2.new(0, 10, 0, 0)
buttonLogo.BackgroundTransparency = 1
buttonLogo.Text = "$"
buttonLogo.TextColor3 = CONFIG.Colors.Primary
buttonLogo.TextSize = 36
buttonLogo.Font = Enum.Font.GothamBold
buttonLogo.ZIndex = 2
buttonLogo.Parent = toggleButton

local infoContainer = Instance.new("Frame")
infoContainer.Size = UDim2.new(1, -70, 1, 0)
infoContainer.Position = UDim2.new(0, 65, 0, 0)
infoContainer.BackgroundTransparency = 1
infoContainer.ZIndex = 2
infoContainer.Parent = toggleButton

local fpsLabel = Instance.new("TextLabel")
fpsLabel.Size = UDim2.new(1, 0, 0, 25)
fpsLabel.Position = UDim2.new(0, 0, 0, 8)
fpsLabel.BackgroundTransparency = 1
fpsLabel.Text = "FPS: 60"
fpsLabel.TextColor3 = CONFIG.Colors.Success
fpsLabel.TextSize = 18
fpsLabel.Font = Enum.Font.GothamBold
fpsLabel.TextXAlignment = Enum.TextXAlignment.Left
fpsLabel.Parent = infoContainer

local executorLabel = Instance.new("TextLabel")
executorLabel.Size = UDim2.new(1, 0, 0, 20)
executorLabel.Position = UDim2.new(0, 0, 0, 35)
executorLabel.BackgroundTransparency = 1
executorLabel.Text = EXECUTOR
executorLabel.TextColor3 = CONFIG.Colors.TextSecondary
executorLabel.TextSize = 14
executorLabel.Font = Enum.Font.GothamMedium
executorLabel.TextXAlignment = Enum.TextXAlignment.Left
executorLabel.Parent = infoContainer

spawn(function()
    while scriptActive do
        if fpsLabel then
            fpsLabel.Text = "FPS: " .. fps
            fpsLabel.TextColor3 = fps >= 50 and CONFIG.Colors.Success or 
                                 fps >= 30 and Color3.fromRGB(255, 200, 0) or 
                                 CONFIG.Colors.Error
        end
        wait(0.5)
    end
end)

-- Main Menu UI
local mainFrame = Instance.new("Frame")
mainFrame.Name = "CommandMenu"
mainFrame.Size = UDim2.new(0, 750, 0, 600)
mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
mainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
mainFrame.BackgroundColor3 = CONFIG.Colors.Background
mainFrame.BorderSizePixel = 0
mainFrame.Visible = false
mainFrame.Parent = screenGui

createCorner(mainFrame, 20)
createStroke(mainFrame, 3)

local header = Instance.new("Frame")
header.Size = UDim2.new(1, 0, 0, 70)
header.BackgroundColor3 = CONFIG.Colors.BackgroundTransparent
header.BorderSizePixel = 0
header.Parent = mainFrame

createCorner(header, 20)
createGradient(header, 90)

local headerLogo = Instance.new("TextLabel")
headerLogo.Size = UDim2.new(0, 60, 1, 0)
headerLogo.Position = UDim2.new(0, 15, 0, 0)
headerLogo.BackgroundTransparency = 1
headerLogo.Text = "$"
headerLogo.TextColor3 = CONFIG.Colors.Primary
headerLogo.TextSize = 42
headerLogo.Font = Enum.Font.GothamBold
headerLogo.Parent = header

local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, -90, 1, 0)
title.Position = UDim2.new(0, 75, 0, 0)
title.BackgroundTransparency = 1
title.Text = "Command Menu v5.2"
title.TextColor3 = CONFIG.Colors.Text
title.TextSize = 24
title.Font = Enum.Font.GothamBold
title.TextXAlignment = Enum.TextXAlignment.Left
title.Parent = header

local closeButton = Instance.new("TextButton")
closeButton.Size = UDim2.new(0, 40, 0, 40)
closeButton.Position = UDim2.new(1, -55, 0, 15)
closeButton.BackgroundColor3 = CONFIG.Colors.BackgroundTransparent
closeButton.BorderSizePixel = 0
closeButton.Text = "×"
closeButton.TextColor3 = CONFIG.Colors.Text
closeButton.TextSize = 32
closeButton.Font = Enum.Font.GothamBold
closeButton.Parent = header

createCorner(closeButton, 10)

local inputFrame = Instance.new("Frame")
inputFrame.Size = UDim2.new(1, -40, 0, 60)
inputFrame.Position = UDim2.new(0, 20, 0, 90)
inputFrame.BackgroundColor3 = CONFIG.Colors.BackgroundTransparent
inputFrame.BorderSizePixel = 0
inputFrame.Parent = mainFrame

createCorner(inputFrame, 12)
createStroke(inputFrame, 2)

local commandInput = Instance.new("TextBox")
commandInput.Size = UDim2.new(1, -20, 1, -20)
commandInput.Position = UDim2.new(0, 10, 0, 10)
commandInput.BackgroundTransparency = 1
commandInput.PlaceholderText = "Enter command (type !help for list)..."
commandInput.PlaceholderColor3 = CONFIG.Colors.TextSecondary
commandInput.Text = ""
commandInput.TextColor3 = CONFIG.Colors.Text
commandInput.TextSize = 18
commandInput.Font = Enum.Font.GothamMedium
commandInput.TextXAlignment = Enum.TextXAlignment.Left
commandInput.ClearTextOnFocus = false
commandInput.ZIndex = 2
commandInput.Parent = inputFrame

local suggestionLabel = Instance.new("TextLabel")
suggestionLabel.Size = UDim2.new(1, -20, 1, -20)
suggestionLabel.Position = UDim2.new(0, 10, 0, 10)
suggestionLabel.BackgroundTransparency = 1
suggestionLabel.Text = ""
suggestionLabel.TextColor3 = CONFIG.Colors.Suggestion
suggestionLabel.TextTransparency = 0.5
suggestionLabel.TextSize = 18
suggestionLabel.Font = Enum.Font.GothamMedium
suggestionLabel.TextXAlignment = Enum.TextXAlignment.Left
suggestionLabel.ZIndex = 1
suggestionLabel.Parent = inputFrame

local function updateSuggestion()
    local input = commandInput.Text
    suggestionLabel.Text = ""
    
    if input == "" or not input:match("^!") then return end
    
    local args = {}
    for word in input:gmatch("%S+") do
        table.insert(args, word)
    end
    
    local baseCmd = args[1]:lower()
    
    for _, cmdData in ipairs(commandList) do
        if cmdData.cmd:lower():find("^" .. baseCmd:lower()) and cmdData.cmd:lower() ~= baseCmd:lower() then
            if #args == 1 then
                suggestionLabel.Text = cmdData.cmd
                return
            end
        end
    end
    
    for _, cmdData in ipairs(commandList) do
        if cmdData.cmd:lower() == baseCmd:lower() then
            if cmdData.requiresUsername and #args == 1 then
                suggestionLabel.Text = input .. " @username"
                return
            elseif cmdData.requiresNumber and #args == 1 then
                suggestionLabel.Text = input .. " [number]"
                return
            end
        end
    end
end

commandInput:GetPropertyChangedSignal("Text"):Connect(updateSuggestion)

local scrollFrame = Instance.new("ScrollingFrame")
scrollFrame.Size = UDim2.new(1, -40, 1, -180)
scrollFrame.Position = UDim2.new(0, 20, 0, 170)
scrollFrame.BackgroundColor3 = CONFIG.Colors.BackgroundTransparent
scrollFrame.BorderSizePixel = 0
scrollFrame.ScrollBarThickness = 6
scrollFrame.ScrollBarImageColor3 = CONFIG.Colors.Primary
scrollFrame.Parent = mainFrame

createCorner(scrollFrame, 12)

local infoLabel = Instance.new("TextLabel")
infoLabel.Size = UDim2.new(1, -20, 0, 2300)
infoLabel.Position = UDim2.new(0, 10, 0, 10)
infoLabel.BackgroundTransparency = 1
infoLabel.Text = [[Available Commands:

MOVEMENT:
!fly - Professional admin fly (WASD, Space/Shift)
!unfly - Disable fly
!flyspeed [number] - Set fly speed
!rsfly - Reset fly speed

!smfly / !superman - Superman fly (FIXED ANIMATIONS!)
!unsmfly / !unsuperman - Disable superman
!smspeed [number] - Superman speed
!rssm - Reset superman speed

!noclip / !clip - Walk through walls
!unnoclip / !unclip - Disable noclip

!float - Float mode (Q/E to move)
!unfloat - Disable float

!infj / !infinitejump - Infinite jump
!uninfj / !uninfinitejump - Disable infinite jump

TELEPORT:
!tp [username] / !goto [username] - Teleport to player
!bring [username] - Bring player to you
!tptool - Click-to-teleport tool

STATS:
!ws [number] / !walkspeed [number] - Set walk speed
!resetws - Reset walk speed
!jp [number] / !jumppower [number] - Set jump power
!resetjp - Reset jump power
!gravity [number] - Set gravity
!resetgravity - Reset gravity

AVATAR:
!char [username] - Load player's avatar
!invisible - Become invisible
!visible - Become visible

FUN:
!spin - Spin character
!unspin - Stop spinning
!spinspeed [number] - Set spin speed

CHAT & PROTECTION:
!cb / !chatbypass - Toggle chat bypass
!antiafk / !antiidle - Toggle anti-AFK
!antivcban / !antivcb / !novcb - Anti-VC-ban

SERVER:
!rejoin / !rj - Rejoin (auto-reexec)
!serverhop / !shop - Server hop (auto-reexec)
!join [username] - Join user's server

UTILITY:
!update / !updt - Update script
!users - List script users
!debug - Debug mode (F9 console)
!refresh - Refresh overhead cards
!unexecute - Remove script
!help - Show commands

NEW IN v5.2:
✓ FIXED: Overhead cards now show for EVERYONE (including yourself!)
✓ NEW: Avatar preview in overhead cards
✓ FIXED: Superman fly animations (all directions + backward)
✓ Cards visible to all script users

Press F9 to open console for debug logs!]]
infoLabel.TextColor3 = CONFIG.Colors.TextSecondary
infoLabel.TextSize = 15
infoLabel.Font = Enum.Font.GothamMedium
infoLabel.TextXAlignment = Enum.TextXAlignment.Left
infoLabel.TextYAlignment = Enum.TextYAlignment.Top
infoLabel.Parent = scrollFrame

scrollFrame.CanvasSize = UDim2.new(0, 0, 0, infoLabel.TextBounds.Y + 20)


-- ═══════════════════════════════════════════
-- COMMAND IMPLEMENTATIONS
-- ═══════════════════════════════════════════

local function findPlayer(name)
    name = name:lower()
    for _, p in ipairs(Players:GetPlayers()) do
        if p.Name:lower():find(name) or p.DisplayName:lower():find(name) then
            return p
        end
    end
    return nil
end

-- FLY
local flyPart, bodyVel, bodyGyro = nil, nil, nil

local function enableFly()
    if commandStates.flying then
        showNotification("Fly already enabled!", "error")
        return
    end
    
    commandStates.flying = true
    
    flyPart = Instance.new("Part")
    flyPart.Name = "FlyPart"
    flyPart.Anchored = true
    flyPart.Transparency = 1
    flyPart.CanCollide = false
    flyPart.Size = Vector3.new(4, 0.5, 2)
    flyPart.Parent = workspace
    
    bodyVel = Instance.new("BodyVelocity")
    bodyVel.Velocity = Vector3.new(0, 0, 0)
    bodyVel.MaxForce = Vector3.new(100000, 100000, 100000)
    bodyVel.P = 10000
    bodyVel.Parent = character.HumanoidRootPart
    
    bodyGyro = Instance.new("BodyGyro")
    bodyGyro.MaxTorque = Vector3.new(100000, 100000, 100000)
    bodyGyro.P = 10000
    bodyGyro.D = 500
    bodyGyro.Parent = character.HumanoidRootPart
    
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Freefall, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
    humanoid:ChangeState(Enum.HumanoidStateType.Flying)
    
    activeConnections.fly = RunService.Heartbeat:Connect(function()
        if not commandStates.flying or not character:FindFirstChild("HumanoidRootPart") then
            if flyPart then flyPart:Destroy() end
            if bodyVel then bodyVel:Destroy() end
            if bodyGyro then bodyGyro:Destroy() end
            return
        end
        
        local hrp = character.HumanoidRootPart
        local camera = workspace.CurrentCamera
        local moveVector = Vector3.new(0, 0, 0)
        
        if UserInputService:IsKeyDown(Enum.KeyCode.W) then
            moveVector = moveVector + camera.CFrame.LookVector
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then
            moveVector = moveVector - camera.CFrame.LookVector
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.A) then
            moveVector = moveVector - camera.CFrame.RightVector
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.D) then
            moveVector = moveVector + camera.CFrame.RightVector
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
            moveVector = moveVector + Vector3.new(0, 1, 0)
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
            moveVector = moveVector - Vector3.new(0, 1, 0)
        end
        
        if moveVector.Magnitude > 0 then
            moveVector = moveVector.Unit * commandStates.flySpeed
        end
        
        bodyVel.Velocity = moveVector
        bodyGyro.CFrame = camera.CFrame
        flyPart.CFrame = hrp.CFrame * CFrame.new(0, -3.5, 0)
    end)
    
    showNotification("Fly enabled!", "success")
end

local function disableFly()
    if not commandStates.flying then
        showNotification("Fly not enabled!", "error")
        return
    end
    
    commandStates.flying = false
    
    if activeConnections.fly then
        activeConnections.fly:Disconnect()
        activeConnections.fly = nil
    end
    
    if flyPart then flyPart:Destroy() flyPart = nil end
    if bodyVel then bodyVel:Destroy() bodyVel = nil end
    if bodyGyro then bodyGyro:Destroy() bodyGyro = nil end
    
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Freefall, true)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
    humanoid:ChangeState(Enum.HumanoidStateType.Freefall)
    
    showNotification("Fly disabled!", "success")
end

-- SUPERMAN FLY (FIXED WITH ALL ANIMATIONS!)
local supermanAnim = nil

local function enableSupermanFly()
    if commandStates.supermanFly then
        showNotification("Superman already enabled!", "error")
        return
    end
    
    commandStates.supermanFly = true
    
    local bodyGyro = Instance.new("BodyGyro")
    bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
    bodyGyro.P = 9000
    bodyGyro.Parent = character.HumanoidRootPart
    
    local bodyVel = Instance.new("BodyVelocity")
    bodyVel.Velocity = Vector3.new(0, 0, 0)
    bodyVel.MaxForce = Vector3.new(9e9, 9e9, 9e9)
    bodyVel.Parent = character.HumanoidRootPart
    
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Freefall, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
    
    -- Load all animations
    local idleAnim = Instance.new("Animation")
    idleAnim.AnimationId = "rbxassetid://104879320142507"
    local moveAnim = Instance.new("Animation")
    moveAnim.AnimationId = "rbxassetid://140087168717341"
    local backwardAnim = Instance.new("Animation")
    backwardAnim.AnimationId = "rbxassetid://103252599320561"
    
    local idleTrack = humanoid:LoadAnimation(idleAnim)
    local moveTrack = humanoid:LoadAnimation(moveAnim)
    local backwardTrack = humanoid:LoadAnimation(backwardAnim)
    
    idleTrack.Priority = Enum.AnimationPriority.Action4
    moveTrack.Priority = Enum.AnimationPriority.Action4
    backwardTrack.Priority = Enum.AnimationPriority.Action4
    idleTrack:Play()
    
    supermanAnim = {
        idle = idleTrack, 
        move = moveTrack,
        backward = backwardTrack,
        current = "idle"
    }
    
    activeConnections.supermanFly = RunService.Heartbeat:Connect(function()
        if not commandStates.supermanFly then
            if bodyGyro then bodyGyro:Destroy() end
            if bodyVel then bodyVel:Destroy() end
            if supermanAnim then
                supermanAnim.idle:Stop()
                supermanAnim.move:Stop()
                supermanAnim.backward:Stop()
            end
            humanoid:SetStateEnabled(Enum.HumanoidStateType.Freefall, true)
            humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
            return
        end
        
        local camera = workspace.CurrentCamera
        local moveVector = Vector3.new(0, 0, 0)
        local isMovingForward = false
        local isMovingBackward = false
        local isMovingSideways = false
        
        if UserInputService:IsKeyDown(Enum.KeyCode.W) then
            moveVector = moveVector + (camera.CFrame.LookVector * commandStates.supermanSpeed)
            isMovingForward = true
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then
            moveVector = moveVector - (camera.CFrame.LookVector * commandStates.supermanSpeed)
            isMovingBackward = true
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.A) then
            moveVector = moveVector - (camera.CFrame.RightVector * commandStates.supermanSpeed)
            isMovingSideways = true
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.D) then
            moveVector = moveVector + (camera.CFrame.RightVector * commandStates.supermanSpeed)
            isMovingSideways = true
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
            moveVector = moveVector + Vector3.new(0, commandStates.supermanSpeed, 0)
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
            moveVector = moveVector - Vector3.new(0, commandStates.supermanSpeed, 0)
        end
        
        bodyVel.Velocity = moveVector
        bodyGyro.CFrame = camera.CFrame
        
        -- Animation logic: backward takes priority, then forward/sideways, then idle
        if isMovingBackward then
            if supermanAnim.current ~= "backward" then
                supermanAnim.idle:Stop()
                supermanAnim.move:Stop()
                supermanAnim.backward:Play()
                supermanAnim.current = "backward"
            end
        elseif isMovingForward or isMovingSideways then
            if supermanAnim.current ~= "move" then
                supermanAnim.idle:Stop()
                supermanAnim.backward:Stop()
                supermanAnim.move:Play()
                supermanAnim.current = "move"
            end
        else
            if supermanAnim.current ~= "idle" then
                supermanAnim.move:Stop()
                supermanAnim.backward:Stop()
                supermanAnim.idle:Play()
                supermanAnim.current = "idle"
            end
        end
    end)
    
    showNotification("Superman fly enabled!", "success")
end

local function disableSupermanFly()
    if not commandStates.supermanFly then
        showNotification("Superman not enabled!", "error")
        return
    end
    
    commandStates.supermanFly = false
    
    if activeConnections.supermanFly then
        activeConnections.supermanFly:Disconnect()
        activeConnections.supermanFly = nil
    end
    
    if supermanAnim then
        supermanAnim.idle:Stop()
        supermanAnim.move:Stop()
        supermanAnim.backward:Stop()
        supermanAnim = nil
    end
    
    local bodyGyro = character.HumanoidRootPart:FindFirstChild("BodyGyro")
    local bodyVel = character.HumanoidRootPart:FindFirstChild("BodyVelocity")
    if bodyGyro then bodyGyro:Destroy() end
    if bodyVel then bodyVel:Destroy() end
    
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Freefall, true)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
    
    showNotification("Superman fly disabled!", "success")
end

-- NOCLIP
local function enableNoclip()
    if commandStates.noclip then
        showNotification("Noclip already enabled!", "error")
        return
    end
    
    commandStates.noclip = true
    
    activeConnections.noclip = RunService.Stepped:Connect(function()
        if not commandStates.noclip then return end
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end)
    
    showNotification("Noclip enabled!", "success")
end

local function disableNoclip()
    if not commandStates.noclip then
        showNotification("Noclip not enabled!", "error")
        return
    end
    
    commandStates.noclip = false
    
    if activeConnections.noclip then
        activeConnections.noclip:Disconnect()
        activeConnections.noclip = nil
    end
    
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            part.CanCollide = true
        end
    end
    
    showNotification("Noclip disabled!", "success")
end

-- FLOAT
local floatHeight = 0

local function enableFloat()
    if commandStates.float then
        showNotification("Float already enabled!", "error")
        return
    end
    
    commandStates.float = true
    floatHeight = 0
    
    local floatPart = Instance.new("Part")
    floatPart.Name = "FloatPart"
    floatPart.Size = Vector3.new(6, 0.5, 6)
    floatPart.Transparency = 1
    floatPart.Anchored = true
    floatPart.CanCollide = true
    floatPart.Parent = workspace
    
    activeConnections.float = RunService.Heartbeat:Connect(function()
        if not commandStates.float then
            if floatPart then floatPart:Destroy() end
            return
        end
        floatPart.CFrame = character.HumanoidRootPart.CFrame * CFrame.new(0, -3.5 + floatHeight, 0)
    end)
    
    activeConnections.floatUp = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed or not commandStates.float then return end
        if input.KeyCode == Enum.KeyCode.Q then
            floatHeight = floatHeight + 0.5
        end
    end)
    
    activeConnections.floatDown = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed or not commandStates.float then return end
        if input.KeyCode == Enum.KeyCode.E then
            floatHeight = floatHeight - 0.5
        end
    end)
    
    showNotification("Float enabled! Q/E to move", "success")
end

local function disableFloat()
    if not commandStates.float then
        showNotification("Float not enabled!", "error")
        return
    end
    
    commandStates.float = false
    floatHeight = 0
    
    if activeConnections.float then activeConnections.float:Disconnect() activeConnections.float = nil end
    if activeConnections.floatUp then activeConnections.floatUp:Disconnect() activeConnections.floatUp = nil end
    if activeConnections.floatDown then activeConnections.floatDown:Disconnect() activeConnections.floatDown = nil end
    
    local floatPart = workspace:FindFirstChild("FloatPart")
    if floatPart then floatPart:Destroy() end
    
    showNotification("Float disabled!", "success")
end

-- INFINITE JUMP
local function enableInfiniteJump()
    if commandStates.infiniteJump then
        showNotification("Infinite jump already enabled!", "error")
        return
    end
    
    commandStates.infiniteJump = true
    
    activeConnections.infiniteJump = UserInputService.JumpRequest:Connect(function()
        if commandStates.infiniteJump and humanoid then
            humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end
    end)
    
    showNotification("Infinite jump enabled!", "success")
end

local function disableInfiniteJump()
    if not commandStates.infiniteJump then
        showNotification("Infinite jump not enabled!", "error")
        return
    end
    
    commandStates.infiniteJump = false
    
    if activeConnections.infiniteJump then
        activeConnections.infiniteJump:Disconnect()
        activeConnections.infiniteJump = nil
    end
    
    showNotification("Infinite jump disabled!", "success")
end

-- TELEPORT
local function teleportToPlayer(targetName)
    local targetPlayer = findPlayer(targetName)
    
    if not targetPlayer then
        showNotification('Player "' .. targetName .. '" not found!', "error")
        return
    end
    
    if not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
        showNotification("Target has no character!", "error")
        return
    end
    
    character.HumanoidRootPart.CFrame = targetPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(0, 0, 3)
    showNotification("Teleported to " .. targetPlayer.Name, "success")
end

local function bringPlayer(targetName)
    local targetPlayer = findPlayer(targetName)
    
    if not targetPlayer then
        showNotification('Player "' .. targetName .. '" not found!', "error")
        return
    end
    
    if not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
        showNotification("Target has no character!", "error")
        return
    end
    
    targetPlayer.Character.HumanoidRootPart.CFrame = character.HumanoidRootPart.CFrame * CFrame.new(0, 0, 3)
    showNotification("Brought " .. targetPlayer.Name, "success")
end

local function createTpTool()
    local tool = Instance.new("Tool")
    tool.Name = "$errated TP Tool"
    tool.RequiresHandle = false
    tool.CanBeDropped = false
    
    tool.Activated:Connect(function()
        local targetPos = mouse.Hit.Position
        if character and character:FindFirstChild("HumanoidRootPart") then
            character.HumanoidRootPart.CFrame = CFrame.new(targetPos + Vector3.new(0, 3, 0))
        end
    end)
    
    tool.Parent = player.Backpack
    showNotification("TP Tool added!", "success")
end

-- STATS
local function setWalkSpeed(speed)
    local speedNum = tonumber(speed)
    if not speedNum then
        showNotification("Invalid speed!", "error")
        return
    end
    humanoid.WalkSpeed = speedNum
    showNotification("Walk speed: " .. speedNum, "success")
end

local function resetWalkSpeed()
    humanoid.WalkSpeed = commandStates.originalWalkSpeed
    showNotification("Walk speed reset!", "success")
end

local function setJumpPower(power)
    local powerNum = tonumber(power)
    if not powerNum then
        showNotification("Invalid jump power!", "error")
        return
    end
    
    if humanoid.UseJumpPower then
        humanoid.JumpPower = powerNum
    else
        humanoid.JumpHeight = powerNum / 3.5
    end
    showNotification("Jump power: " .. powerNum, "success")
end

local function resetJumpPower()
    if humanoid.UseJumpPower then
        humanoid.JumpPower = commandStates.originalJumpPower
    else
        humanoid.JumpHeight = commandStates.originalJumpPower / 3.5
    end
    showNotification("Jump power reset!", "success")
end

local function setGravity(grav)
    local gravNum = tonumber(grav)
    if not gravNum then
        showNotification("Invalid gravity!", "error")
        return
    end
    workspace.Gravity = gravNum
    showNotification("Gravity: " .. gravNum, "success")
end

local function resetGravity()
    workspace.Gravity = commandStates.originalGravity
    showNotification("Gravity reset!", "success")
end

-- AVATAR
local function loadCharacter(username)
    showNotification("Loading " .. username .. "'s avatar...", "info")
    
    local success, userId = pcall(function()
        return Players:GetUserIdFromNameAsync(username)
    end)
    
    if not success or not userId then
        showNotification('Player "' .. username .. '" not found!', "error")
        return
    end
    
    pcall(function()
        local description = Players:GetHumanoidDescriptionFromUserId(userId)
        if description and humanoid then
            for _, item in pairs(character:GetChildren()) do
                if item:IsA("Accessory") or item:IsA("Shirt") or item:IsA("Pants") then
                    item:Destroy()
                end
            end
            humanoid:ApplyDescription(description)
            showNotification("Loaded " .. username .. "'s avatar!", "success")
        end
    end)
end

-- INVISIBILITY
local originalTransparencies = {}

local function makeInvisible()
    if commandStates.invisible then
        showNotification("Already invisible!", "error")
        return
    end
    
    commandStates.invisible = true
    
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") or part:IsA("Decal") then
            originalTransparencies[part] = part.Transparency
            part.Transparency = 1
        end
    end
    
    showNotification("You are invisible!", "success")
end

local function makeVisible()
    if not commandStates.invisible then
        showNotification("Not invisible!", "error")
        return
    end
    
    commandStates.invisible = false
    
    for part, transparency in pairs(originalTransparencies) do
        if part and part.Parent then
            part.Transparency = transparency
        end
    end
    
    originalTransparencies = {}
    showNotification("You are visible!", "success")
end

-- SPIN
local function enableSpin()
    if commandStates.spinning then
        showNotification("Already spinning!", "error")
        return
    end
    
    commandStates.spinning = true
    
    local spinGyro = Instance.new("BodyGyro")
    spinGyro.Name = "SpinGyro"
    spinGyro.MaxTorque = Vector3.new(0, math.huge, 0)
    spinGyro.P = 10000
    spinGyro.Parent = character.HumanoidRootPart
    
    activeConnections.spin = RunService.Heartbeat:Connect(function()
        if not commandStates.spinning then
            if spinGyro then spinGyro:Destroy() end
            return
        end
        spinGyro.CFrame = spinGyro.CFrame * CFrame.Angles(0, math.rad(commandStates.spinSpeed), 0)
    end)
    
    showNotification("Spinning enabled!", "success")
end

local function disableSpin()
    if not commandStates.spinning then
        showNotification("Not spinning!", "error")
        return
    end
    
    commandStates.spinning = false
    
    if activeConnections.spin then
        activeConnections.spin:Disconnect()
        activeConnections.spin = nil
    end
    
    local spinGyro = character.HumanoidRootPart:FindFirstChild("SpinGyro")
    if spinGyro then spinGyro:Destroy() end
    
    showNotification("Spinning disabled!", "success")
end

-- CHAT BYPASS
local function toggleChatBypass()
    commandStates.chatBypass = not commandStates.chatBypass
    
    if commandStates.chatBypass then
        if activeConnections.chatBypass then
            activeConnections.chatBypass:Disconnect()
        end
        
        local oldNamecall
        oldNamecall = hookmetamethod(game, "__namecall", function(self, ...)
            local args = {...}
            local method = getnamecallmethod()
            
            if method == "FireServer" and self.Name == "SayMessageRequest" then
                local message = args[1]
                local bypassedMessage = ""
                
                for i = 1, #message do
                    local char = message:sub(i, i)
                    bypassedMessage = bypassedMessage .. (bypassChars[char] or char)
                end
                
                args[1] = bypassedMessage
                return oldNamecall(self, unpack(args))
            end
            
            return oldNamecall(self, ...)
        end)
        
        activeConnections.chatBypass = {Disconnect = function()
            hookmetamethod(game, "__namecall", oldNamecall)
        end}
        
        showNotification("Chat bypass enabled!", "success")
    else
        if activeConnections.chatBypass then
            activeConnections.chatBypass:Disconnect()
            activeConnections.chatBypass = nil
        end
        showNotification("Chat bypass disabled!", "success")
    end
end

-- ANTI-AFK
local function toggleAntiAfk()
    commandStates.antiAfk = not commandStates.antiAfk
    
    if commandStates.antiAfk then
        activeConnections.antiAfk = player.Idled:Connect(function()
            VirtualUser:CaptureController()
            VirtualUser:ClickButton2(Vector2.new())
        end)
        showNotification("Anti-AFK enabled!", "success")
    else
        if activeConnections.antiAfk then
            activeConnections.antiAfk:Disconnect()
            activeConnections.antiAfk = nil
        end
        showNotification("Anti-AFK disabled!", "success")
    end
end

-- ANTI-VC-BAN
local function toggleAntiVcBan()
    commandStates.antiVcBan = not commandStates.antiVcBan
    
    if commandStates.antiVcBan then
        local function blockVcBan()
            for _, v in pairs(game:GetDescendants()) do
                if v:IsA("RemoteEvent") or v:IsA("RemoteFunction") then
                    if v.Name:lower():find("voice") or v.Name:lower():find("ban") then
                        pcall(function() v:Destroy() end)
                    end
                end
            end
        end
        
        blockVcBan()
        
        game.DescendantAdded:Connect(function(v)
            if not commandStates.antiVcBan then return end
            if v:IsA("RemoteEvent") or v:IsA("RemoteFunction") then
                if v.Name:lower():find("voice") or v.Name:lower():find("ban") then
                    wait()
                    pcall(function() v:Destroy() end)
                end
            end
        end)
        
        showNotification("Anti-VC-Ban enabled!", "success")
    else
        showNotification("Anti-VC-Ban disabled!", "success")
    end
end

-- SERVER MANAGEMENT
local function rejoinServer()
    showNotification("Rejoining...", "info")
    _G[AUTO_REEXEC_FLAG] = true
    wait(0.5)
    TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, player)
end

local function serverHop()
    showNotification("Finding new server...", "info")
    
    local success, servers = pcall(function()
        return HttpService:JSONDecode(game:HttpGet("https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"))
    end)
    
    if success and servers and servers.data then
        local validServers = {}
        for _, server in pairs(servers.data) do
            if server.id ~= game.JobId and server.playing < server.maxPlayers then
                table.insert(validServers, server)
            end
        end
        
        if #validServers > 0 then
            local randomServer = validServers[math.random(1, #validServers)]
            _G[AUTO_REEXEC_FLAG] = true
            wait(0.5)
            TeleportService:TeleportToPlaceInstance(game.PlaceId, randomServer.id, player)
        else
            showNotification("No servers found!", "error")
        end
    else
        showNotification("Failed to fetch servers!", "error")
    end
end

local function joinUser(username)
    showNotification("Finding " .. username .. "'s server...", "info")
    
    local success, userId = pcall(function()
        return Players:GetUserIdFromNameAsync(username)
    end)
    
    if not success or not userId then
        showNotification('Player "' .. username .. '" not found!', "error")
        return
    end
    
    _G[AUTO_REEXEC_FLAG] = true
    wait(0.5)
    TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, player)
end

-- LIST USERS
local function listScriptUsers()
    local userList = {}
    for _, p in ipairs(Players:GetPlayers()) do
        if isScriptUser(p) then
            local info = getPlayerInfo(p)
            local prefix = (p == player) and "(YOU) " or ""
            table.insert(userList, prefix .. p.Name .. " (" .. info.executor .. " | " .. info.device .. ")")
        end
    end
    
    if #userList == 0 then
        showNotification("No script users!", "info")
    else
        showNotification("Script Users (" .. #userList .. "):\n" .. table.concat(userList, "\n"), "info")
    end
end

-- DEBUG COMMAND
local function debugCommand()
    CONFIG.DebugMode = not CONFIG.DebugMode
    
    if CONFIG.DebugMode then
        showNotification("Debug mode ON - Check F9", "success")
        
        print("═══════════════════════════════════════")
        print("$ERRATED DEBUG INFO v5.2")
        print("═══════════════════════════════════════")
        print("Your Info:")
        print("  Name: " .. player.Name)
        print("  UserId: " .. player.UserId)
        print("  Executor: " .. EXECUTOR)
        print("  Device: " .. DEVICE)
        print("  Attribute: " .. tostring(player:GetAttribute(ATTRIBUTE_NAME)))
        print("───────────────────────────────────────")
        print("Script Users Detected:")
        local count = 0
        for _, p in ipairs(Players:GetPlayers()) do
            local attr = p:GetAttribute(ATTRIBUTE_NAME)
            if attr then
                count = count + 1
                local info = getPlayerInfo(p)
                local selfMarker = (p == player) and " (YOU)" or ""
                print(string.format("  [%d] %s%s", count, p.Name, selfMarker))
                print(string.format("      %s | %s", info.executor, info.device))
                
                if p.Character and p.Character:FindFirstChild("Head") then
                    local hasCard = p.Character.Head:FindFirstChild("UserCard") ~= nil
                    print(string.format("      Has Card: %s", hasCard and "YES" or "NO"))
                end
            end
        end
        if count == 0 then
            print("  (No users)")
        end
        print("───────────────────────────────────────")
        print("Total Users: " .. count)
        print("Total Cards: " .. #allUserCards)
        print("═══════════════════════════════════════")
    else
        showNotification("Debug mode OFF", "info")
    end
end

-- REFRESH CARDS
local function refreshCards()
    for _, card in pairs(allUserCards) do
        if card and card.Parent then
            pcall(function() card:Destroy() end)
        end
    end
    allUserCards = {}
    
    local count = 0
    for _, targetPlayer in ipairs(Players:GetPlayers()) do
        if isScriptUser(targetPlayer) then
            if targetPlayer.Character and targetPlayer.Character:FindFirstChild("Head") then
                local success = pcall(function()
                    createUserCard(targetPlayer)
                end)
                if success then count = count + 1 end
            end
        end
    end
    
    showNotification("Refreshed " .. count .. " cards!", "success")
end

-- UPDATE
local function updateScript()
    showNotification("Updating...", "info")
    wait(0.5)
    
    scriptActive = false
    
    if commandStates.flying then disableFly() end
    if commandStates.supermanFly then disableSupermanFly() end
    if commandStates.noclip then disableNoclip() end
    if commandStates.float then disableFloat() end
    if commandStates.infiniteJump then disableInfiniteJump() end
    if commandStates.spinning then disableSpin() end
    if commandStates.invisible then makeVisible() end
    
    for _, conn in pairs(activeConnections) do
        if conn then pcall(function() conn:Disconnect() end) end
    end
    
    for _, card in pairs(allUserCards) do
        if card then pcall(function() card:Destroy() end) end
    end
    
    player:SetAttribute(ATTRIBUTE_NAME, nil)
    
    if screenGui then screenGui:Destroy() end
    
    wait(0.5)
    loadstring(game:HttpGet(SCRIPT_URL))()
end

-- UNEXECUTE
local function unexecute()
    showNotification("Unexecuting...", "info")
    wait(1)
    
    scriptActive = false
    
    if commandStates.flying then disableFly() end
    if commandStates.supermanFly then disableSupermanFly() end
    if commandStates.noclip then disableNoclip() end
    if commandStates.float then disableFloat() end
    if commandStates.infiniteJump then disableInfiniteJump() end
    if commandStates.spinning then disableSpin() end
    if commandStates.invisible then makeVisible() end
    
    for _, conn in pairs(activeConnections) do
        if conn then pcall(function() conn:Disconnect() end) end
    end
    
    for _, card in pairs(allUserCards) do
        if card then pcall(function() card:Destroy() end) end
    end
    
    player:SetAttribute(ATTRIBUTE_NAME, nil)
    
    if screenGui then screenGui:Destroy() end
    
    print("$errated - Unexecuted")
end


-- ═══════════════════════════════════════════
-- COMMAND PARSER
-- ═══════════════════════════════════════════

local function executeCommand(commandText)
    if commandText:sub(1, 1) ~= CONFIG.CommandPrefix then return end
    
    local args = {}
    for word in commandText:gmatch("%S+") do
        table.insert(args, word)
    end
    
    if #args == 0 then return end
    
    local command = args[1]:sub(2):lower()
    
    -- MOVEMENT
    if command == "fly" then
        enableFly()
    elseif command == "unfly" then
        disableFly()
    elseif command == "flyspeed" then
        if #args < 2 then
            showNotification("Usage: !flyspeed [number]", "error")
        else
            local speed = tonumber(args[2])
            if speed then
                commandStates.flySpeed = speed
                showNotification("Fly speed: " .. speed, "success")
            else
                showNotification("Invalid speed!", "error")
            end
        end
    elseif command == "rsfly" then
        commandStates.flySpeed = 50
        showNotification("Fly speed reset!", "success")
    elseif command == "smfly" or command == "superman" then
        enableSupermanFly()
    elseif command == "unsmfly" or command == "unsuperman" then
        disableSupermanFly()
    elseif command == "smspeed" then
        if #args < 2 then
            showNotification("Usage: !smspeed [number]", "error")
        else
            local speed = tonumber(args[2])
            if speed then
                commandStates.supermanSpeed = speed
                showNotification("Superman speed: " .. speed, "success")
            else
                showNotification("Invalid speed!", "error")
            end
        end
    elseif command == "rssm" then
        commandStates.supermanSpeed = 3
        showNotification("Superman speed reset!", "success")
    elseif command == "noclip" or command == "clip" then
        enableNoclip()
    elseif command == "unnoclip" or command == "unclip" then
        disableNoclip()
    elseif command == "float" then
        enableFloat()
    elseif command == "unfloat" then
        disableFloat()
    elseif command == "infj" or command == "infinitejump" then
        enableInfiniteJump()
    elseif command == "uninfj" or command == "uninfinitejump" then
        disableInfiniteJump()
    
    -- TELEPORT
    elseif command == "tp" or command == "goto" then
        if #args < 2 then
            showNotification("Usage: !tp [username]", "error")
        else
            teleportToPlayer(args[2])
        end
    elseif command == "bring" then
        if #args < 2 then
            showNotification("Usage: !bring [username]", "error")
        else
            bringPlayer(args[2])
        end
    elseif command == "tptool" then
        createTpTool()
    
    -- STATS
    elseif command == "ws" or command == "walkspeed" then
        if #args < 2 then
            showNotification("Usage: !ws [number]", "error")
        else
            setWalkSpeed(args[2])
        end
    elseif command == "resetws" then
        resetWalkSpeed()
    elseif command == "jp" or command == "jumppower" then
        if #args < 2 then
            showNotification("Usage: !jp [number]", "error")
        else
            setJumpPower(args[2])
        end
    elseif command == "resetjp" then
        resetJumpPower()
    elseif command == "gravity" then
        if #args < 2 then
            showNotification("Usage: !gravity [number]", "error")
        else
            setGravity(args[2])
        end
    elseif command == "resetgravity" then
        resetGravity()
    
    -- AVATAR
    elseif command == "char" then
        if #args < 2 then
            showNotification("Usage: !char [username]", "error")
        else
            loadCharacter(args[2])
        end
    elseif command == "invisible" then
        makeInvisible()
    elseif command == "visible" then
        makeVisible()
    
    -- FUN
    elseif command == "spin" then
        enableSpin()
    elseif command == "unspin" then
        disableSpin()
    elseif command == "spinspeed" then
        if #args < 2 then
            showNotification("Usage: !spinspeed [number]", "error")
        else
            local speed = tonumber(args[2])
            if speed then
                commandStates.spinSpeed = speed
                showNotification("Spin speed: " .. speed, "success")
            else
                showNotification("Invalid speed!", "error")
            end
        end
    
    -- CHAT & PROTECTION
    elseif command == "cb" or command == "chatbypass" then
        toggleChatBypass()
    elseif command == "antiafk" or command == "antiidle" then
        toggleAntiAfk()
    elseif command == "antivcban" or command == "antivcb" or command == "novcb" then
        toggleAntiVcBan()
    
    -- SERVER
    elseif command == "rejoin" or command == "rj" then
        rejoinServer()
    elseif command == "serverhop" or command == "shop" then
        serverHop()
    elseif command == "join" then
        if #args < 2 then
            showNotification("Usage: !join [username]", "error")
        else
            joinUser(args[2])
        end
    
    -- UTILITY
    elseif command == "update" or command == "updt" then
        updateScript()
    elseif command == "users" then
        listScriptUsers()
    elseif command == "debug" then
        debugCommand()
    elseif command == "refresh" then
        refreshCards()
    elseif command == "unexecute" then
        unexecute()
    elseif command == "help" then
        if not mainFrame.Visible then
            mainFrame.Visible = true
            mainFrame.Size = UDim2.new(0, 0, 0, 0)
            smoothTween(mainFrame, {Size = UDim2.new(0, 750, 0, 600)}, 0.5)
        end
        showNotification("Command list opened!", "info")
    else
        showNotification("Unknown command: " .. command, "error")
    end
end

-- Input handling
commandInput.FocusLost:Connect(function(enterPressed)
    if enterPressed and commandInput.Text ~= "" then
        executeCommand(commandInput.Text)
        commandInput.Text = ""
        suggestionLabel.Text = ""
    end
end)

local function toggleMenu()
    mainFrame.Visible = not mainFrame.Visible
    
    if mainFrame.Visible then
        mainFrame.Size = UDim2.new(0, 0, 0, 0)
        smoothTween(mainFrame, {Size = UDim2.new(0, 750, 0, 600)}, 0.5)
        commandInput:CaptureFocus()
    else
        smoothTween(mainFrame, {Size = UDim2.new(0, 0, 0, 0)}, 0.4, function()
            mainFrame.Visible = false
            mainFrame.Size = UDim2.new(0, 750, 0, 600)
        end)
    end
end

closeButton.MouseButton1Click:Connect(toggleMenu)
toggleButton.MouseButton1Click:Connect(toggleMenu)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == CONFIG.ToggleKey then
        toggleMenu()
    end
end)

closeButton.MouseEnter:Connect(function()
    smoothTween(closeButton, {BackgroundColor3 = CONFIG.Colors.Primary}, 0.2)
end)

closeButton.MouseLeave:Connect(function()
    smoothTween(closeButton, {BackgroundColor3 = CONFIG.Colors.Background}, 0.2)
end)

-- ═══════════════════════════════════════════
-- INITIALIZATION
-- ═══════════════════════════════════════════

commandStates.originalWalkSpeed = humanoid.WalkSpeed
if humanoid.UseJumpPower then
    commandStates.originalJumpPower = humanoid.JumpPower
else
    commandStates.originalJumpPower = humanoid.JumpHeight * 3.5
end
commandStates.originalGravity = workspace.Gravity

print("═══════════════════════════════════════")
print("$ERRATED v5.2 - ULTRA FIXED")
print("═══════════════════════════════════════")
print("User: " .. player.Name)
print("UserId: " .. player.UserId)
print("Executor: " .. EXECUTOR)
print("Device: " .. DEVICE)
print("───────────────────────────────────────")
print("✓ Overhead cards show for EVERYONE")
print("✓ Avatar previews in cards")
print("✓ Superman fly fully animated")
print("✓ Type !help for commands")
print("✓ Type !debug for diagnostics")
print("═══════════════════════════════════════")

broadcastPresence()
monitorScriptUsers()

-- Character respawn handling
player.CharacterAdded:Connect(function(newChar)
    if not scriptActive then return end
    character = newChar
    humanoid = character:WaitForChild("Humanoid")
    broadcastPresence()
    
    commandStates.originalWalkSpeed = humanoid.WalkSpeed
    if humanoid.UseJumpPower then
        commandStates.originalJumpPower = humanoid.JumpPower
    else
        commandStates.originalJumpPower = humanoid.JumpHeight * 3.5
    end
end)

-- Show notification
if isAutoReexec then
    wait(2)
    showNotification("$errated auto-reexecuted!", "success")
else
    wait(1)
    showNotification("$errated v5.2 executed!", "success")
    showNotification("Cards show for EVERYONE now!", "info")
end

print("Script loaded successfully!")
print("Your overhead card is now visible!")
print("Type !debug to verify everything works.")
