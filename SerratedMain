--[[
    Modern Command Menu Script v5.0 - PROFESSIONAL EDITION
    Features:
    - Fixed overhead cards showing for ALL script users
    - Auto-reexecution on rejoin/server hop
    - Improved draggable button styling
    - !update command for easy script updates
    - Fixed admin fly (stable, no bugs)
    - Professional UI/UX
    - New commands and features
]]

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local StarterGui = game:GetService("StarterGui")
local TeleportService = game:GetService("TeleportService")
local VirtualUser = game:GetService("VirtualUser")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local mouse = player:GetMouse()

-- Auto-reexecution setup
local SCRIPT_URL = "https://raw.githubusercontent.com/Zay-Aka-Yuji/Serrated/refs/heads/main/SerratedMain"
local AUTO_REEXEC_FLAG = "SERRATED_AUTO_REEXEC"

-- Check if this is an auto-reexecution
local isAutoReexec = false
if _G[AUTO_REEXEC_FLAG] then
    isAutoReexec = true
    _G[AUTO_REEXEC_FLAG] = nil
end

-- Detect Executor
local function getExecutor()
    if identifyexecutor then
        return identifyexecutor()
    elseif KRNL_LOADED then
        return "KRNL"
    elseif syn then
        return "Synapse X"
    elseif SENTINEL_LOADED then
        return "Sentinel"
    elseif getexecutorname then
        return getexecutorname()
    else
        return "Unknown"
    end
end

-- Detect Device
local function getDevice()
    if UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled then
        return "Mobile"
    elseif UserInputService.KeyboardEnabled and not UserInputService.TouchEnabled then
        return "PC"
    elseif UserInputService.GamepadEnabled then
        return "Console"
    else
        return "PC"
    end
end

local EXECUTOR = getExecutor()
local DEVICE = getDevice()

-- Configuration
local CONFIG = {
    Colors = {
        Primary = Color3.fromRGB(138, 43, 226),
        Secondary = Color3.fromRGB(75, 0, 130),
        Background = Color3.fromRGB(20, 20, 20),
        BackgroundTransparent = Color3.fromRGB(15, 15, 15),
        Text = Color3.fromRGB(255, 255, 255),
        TextSecondary = Color3.fromRGB(200, 200, 200),
        Success = Color3.fromRGB(100, 200, 100),
        Error = Color3.fromRGB(220, 80, 80),
        Suggestion = Color3.fromRGB(150, 150, 150)
    },
    Animations = {
        Speed = 0.4,
        EasingStyle = Enum.EasingStyle.Quint,
        EasingDirection = Enum.EasingDirection.Out
    },
    ToggleKey = Enum.KeyCode.RightControl,
    CommandPrefix = "!",
    ScriptIdentifier = "CMD_MENU_USER"
}

-- Command List for Autocomplete
local commandList = {
    -- Movement
    {cmd = "!fly", desc = "Enable admin fly", requiresUsername = false},
    {cmd = "!unfly", desc = "Disable fly", requiresUsername = false},
    {cmd = "!flyspeed", desc = "Set fly speed", requiresUsername = false, requiresNumber = true},
    {cmd = "!rsfly", desc = "Reset fly speed", requiresUsername = false},
    {cmd = "!smfly", desc = "Superman fly", requiresUsername = false},
    {cmd = "!superman", desc = "Superman fly", requiresUsername = false},
    {cmd = "!unsmfly", desc = "Disable superman", requiresUsername = false},
    {cmd = "!unsuperman", desc = "Disable superman", requiresUsername = false},
    {cmd = "!smspeed", desc = "Set superman speed", requiresUsername = false, requiresNumber = true},
    {cmd = "!rssm", desc = "Reset superman speed", requiresUsername = false},
    {cmd = "!noclip", desc = "Walk through walls", requiresUsername = false},
    {cmd = "!clip", desc = "Walk through walls", requiresUsername = false},
    {cmd = "!unnoclip", desc = "Disable noclip", requiresUsername = false},
    {cmd = "!unclip", desc = "Disable noclip", requiresUsername = false},
    {cmd = "!float", desc = "Float mode", requiresUsername = false},
    {cmd = "!unfloat", desc = "Disable float", requiresUsername = false},
    {cmd = "!infj", desc = "Infinite jump", requiresUsername = false},
    {cmd = "!infinitejump", desc = "Infinite jump", requiresUsername = false},
    {cmd = "!uninfj", desc = "Disable infinite jump", requiresUsername = false},
    {cmd = "!uninfinitejump", desc = "Disable infinite jump", requiresUsername = false},
    
    -- Teleport
    {cmd = "!tp", desc = "Teleport to player", requiresUsername = true},
    {cmd = "!goto", desc = "Teleport to player", requiresUsername = true},
    {cmd = "!tptool", desc = "Click teleport tool", requiresUsername = false},
    {cmd = "!bring", desc = "Bring player to you", requiresUsername = true},
    
    -- Stats
    {cmd = "!ws", desc = "Set walkspeed", requiresUsername = false, requiresNumber = true},
    {cmd = "!walkspeed", desc = "Set walkspeed", requiresUsername = false, requiresNumber = true},
    {cmd = "!resetws", desc = "Reset walkspeed", requiresUsername = false},
    {cmd = "!jp", desc = "Set jump power", requiresUsername = false, requiresNumber = true},
    {cmd = "!jumppower", desc = "Set jump power", requiresUsername = false, requiresNumber = true},
    {cmd = "!resetjp", desc = "Reset jump power", requiresUsername = false},
    {cmd = "!gravity", desc = "Set gravity", requiresUsername = false, requiresNumber = true},
    {cmd = "!resetgravity", desc = "Reset gravity", requiresUsername = false},
    
    -- Avatar
    {cmd = "!char", desc = "Load player avatar", requiresUsername = true},
    {cmd = "!invisible", desc = "Become invisible", requiresUsername = false},
    {cmd = "!visible", desc = "Become visible", requiresUsername = false},
    
    -- Chat & Protection
    {cmd = "!cb", desc = "Toggle chat bypass", requiresUsername = false},
    {cmd = "!chatbypass", desc = "Toggle chat bypass", requiresUsername = false},
    {cmd = "!antiafk", desc = "Toggle anti-AFK", requiresUsername = false},
    {cmd = "!antiidle", desc = "Toggle anti-AFK", requiresUsername = false},
    {cmd = "!antivcban", desc = "Toggle anti-VC-ban", requiresUsername = false},
    {cmd = "!antivcb", desc = "Toggle anti-VC-ban", requiresUsername = false},
    {cmd = "!novcb", desc = "Toggle anti-VC-ban", requiresUsername = false},
    
    -- Server
    {cmd = "!rejoin", desc = "Rejoin server", requiresUsername = false},
    {cmd = "!rj", desc = "Rejoin server", requiresUsername = false},
    {cmd = "!serverhop", desc = "Server hop", requiresUsername = false},
    {cmd = "!shop", desc = "Server hop", requiresUsername = false},
    {cmd = "!join", desc = "Join player's server", requiresUsername = true},
    
    -- Fun
    {cmd = "!spin", desc = "Spin character", requiresUsername = false},
    {cmd = "!unspin", desc = "Stop spinning", requiresUsername = false},
    {cmd = "!spinspeed", desc = "Set spin speed", requiresUsername = false, requiresNumber = true},
    
    -- Utility
    {cmd = "!update", desc = "Update script", requiresUsername = false},
    {cmd = "!updt", desc = "Update script", requiresUsername = false},
    {cmd = "!unexecute", desc = "Remove script", requiresUsername = false},
    {cmd = "!help", desc = "Show commands", requiresUsername = false},
    {cmd = "!users", desc = "List script users", requiresUsername = false}
}

-- Command State Management
local commandStates = {
    flying = false,
    noclip = false,
    float = false,
    infiniteJump = false,
    supermanFly = false,
    chatBypass = false,
    antiAfk = false,
    antiVcBan = false,
    spinning = false,
    invisible = false,
    flySpeed = 50,
    supermanSpeed = 3,
    spinSpeed = 10,
    originalWalkSpeed = 16,
    originalJumpPower = 50,
    originalGravity = 196.2
}

local activeConnections = {
    fly = nil,
    noclip = nil,
    float = nil,
    infiniteJump = nil,
    supermanFly = nil,
    floatUp = nil,
    floatDown = nil,
    antiAfk = nil,
    chatBypass = nil,
    spin = nil,
    cardMonitor = nil,
    playerMonitor = nil
}

local scriptUsers = {}
local scriptActive = true
local allUserCards = {}

-- Chat Bypass Characters
local bypassChars = {
    ["a"] = "а", ["e"] = "е", ["o"] = "о", ["p"] = "р", ["c"] = "с",
    ["y"] = "у", ["x"] = "х", ["i"] = "і", ["s"] = "ѕ", ["h"] = "һ",
    ["A"] = "А", ["B"] = "В", ["C"] = "С", ["E"] = "Е", ["H"] = "Н",
    ["I"] = "І", ["K"] = "К", ["M"] = "М", ["O"] = "О", ["P"] = "Р",
    ["S"] = "Ѕ", ["T"] = "Т", ["X"] = "Х", ["Y"] = "У"
}

-- Mark as script user (FIXED - Uses Attributes for cross-client replication)
local function markAsScriptUser()
    if character then
        -- Use Attributes instead of BoolValue - these replicate across clients!
        character:SetAttribute(CONFIG.ScriptIdentifier, true)
        character:SetAttribute("ExecutorInfo", EXECUTOR)
        character:SetAttribute("DeviceInfo", DEVICE)
    end
end

local function isScriptUser(targetPlayer)
    if targetPlayer.Character then
        local hasAttribute = targetPlayer.Character:GetAttribute(CONFIG.ScriptIdentifier)
        return hasAttribute == true
    end
    return false
end

local function getPlayerInfo(targetPlayer)
    if targetPlayer.Character then
        local executor = targetPlayer.Character:GetAttribute("ExecutorInfo")
        local device = targetPlayer.Character:GetAttribute("DeviceInfo")
        return {
            executor = executor or "Unknown",
            device = device or "Unknown"
        }
    end
    return {executor = "Unknown", device = "Unknown"}
end

-- UI Creation
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "CommandMenuGui"
screenGui.ResetOnSpawn = false
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.Parent = playerGui

-- Utility Functions
local function createGradient(parent, rotation)
    local gradient = Instance.new("UIGradient")
    gradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, CONFIG.Colors.Secondary),
        ColorSequenceKeypoint.new(1, CONFIG.Colors.Primary)
    }
    gradient.Rotation = rotation or 45
    gradient.Parent = parent
    return gradient
end

local function createCorner(parent, radius)
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, radius or 12)
    corner.Parent = parent
    return corner
end

local function createStroke(parent, thickness, color)
    local stroke = Instance.new("UIStroke")
    stroke.Thickness = thickness or 2
    stroke.Color = color or CONFIG.Colors.Primary
    stroke.Transparency = 0.3
    stroke.Parent = parent
    return stroke
end

local function smoothTween(instance, properties, duration, callback)
    duration = duration or CONFIG.Animations.Speed
    local tweenInfo = TweenInfo.new(
        duration,
        CONFIG.Animations.EasingStyle,
        CONFIG.Animations.EasingDirection
    )
    
    local tween = TweenService:Create(instance, tweenInfo, properties)
    tween:Play()
    
    if callback then
        tween.Completed:Connect(callback)
    end
    
    return tween
end

-- Notification System
local notificationQueue = {}
local notificationActive = false

local function showNotification(message, notifType)
    table.insert(notificationQueue, {message = message, type = notifType or "info"})
    
    if not notificationActive then
        notificationActive = true
        
        local function processQueue()
            if #notificationQueue == 0 then
                notificationActive = false
                return
            end
            
            local data = table.remove(notificationQueue, 1)
            
            local notif = Instance.new("Frame")
            notif.Size = UDim2.new(0, 400, 0, 80)
            notif.Position = UDim2.new(1, -420, 0, 100)
            notif.BackgroundColor3 = CONFIG.Colors.BackgroundTransparent
            notif.BorderSizePixel = 0
            notif.Parent = screenGui
            
            createCorner(notif, 16)
            
            local stroke = createStroke(notif, 2, data.type == "error" and CONFIG.Colors.Error or CONFIG.Colors.Primary)
            stroke.Transparency = 0
            
            local iconContainer = Instance.new("Frame")
            iconContainer.Size = UDim2.new(0, 60, 1, 0)
            iconContainer.BackgroundColor3 = data.type == "error" and CONFIG.Colors.Error or CONFIG.Colors.Primary
            iconContainer.BorderSizePixel = 0
            iconContainer.Parent = notif
            
            createCorner(iconContainer, 16)
            
            local logo = Instance.new("TextLabel")
            logo.Size = UDim2.new(1, 0, 1, 0)
            logo.BackgroundTransparency = 1
            logo.Text = "$"
            logo.TextColor3 = CONFIG.Colors.Text
            logo.TextSize = 36
            logo.Font = Enum.Font.GothamBold
            logo.Parent = iconContainer
            
            local messageLabel = Instance.new("TextLabel")
            messageLabel.Size = UDim2.new(1, -80, 1, -20)
            messageLabel.Position = UDim2.new(0, 70, 0, 10)
            messageLabel.BackgroundTransparency = 1
            messageLabel.Text = data.message
            messageLabel.TextColor3 = CONFIG.Colors.Text
            messageLabel.TextSize = 16
            messageLabel.Font = Enum.Font.GothamMedium
            messageLabel.TextWrapped = true
            messageLabel.TextXAlignment = Enum.TextXAlignment.Left
            messageLabel.Parent = notif
            
            smoothTween(notif, {Position = UDim2.new(1, -420, 0, 100)}, 0.5)
            
            wait(3)
            
            smoothTween(notif, {Position = UDim2.new(1, 50, 0, 100)}, 0.5, function()
                notif:Destroy()
                processQueue()
            end)
        end
        
        processQueue()
    end
end

-- User Card with Typing Animation and Cursor
local function createUserCard(targetPlayer)
    if not isScriptUser(targetPlayer) then return end
    
    local targetCharacter = targetPlayer.Character
    if not targetCharacter then return end
    
    local head = targetCharacter:FindFirstChild("Head")
    if not head then return end
    
    local existingCard = head:FindFirstChild("UserCard")
    if existingCard then existingCard:Destroy() end
    
    local playerInfo = getPlayerInfo(targetPlayer)
    
    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Name = "UserCard"
    billboardGui.Size = UDim2.new(0, 280, 0, 80)
    billboardGui.StudsOffset = Vector3.new(0, 3.5, 0)
    billboardGui.AlwaysOnTop = true
    billboardGui.Parent = head
    
    -- Store reference for cleanup
    table.insert(allUserCards, billboardGui)
    
    local card = Instance.new("Frame")
    card.Size = UDim2.new(1, 0, 1, 0)
    card.BackgroundColor3 = CONFIG.Colors.Background
    card.BorderSizePixel = 0
    card.BackgroundTransparency = 0.15
    card.Parent = billboardGui
    
    createCorner(card, 14)
    createStroke(card, 2)
    
    local glow = Instance.new("Frame")
    glow.Size = UDim2.new(1, 4, 1, 4)
    glow.Position = UDim2.new(0, -2, 0, -2)
    glow.BackgroundColor3 = CONFIG.Colors.Primary
    glow.BackgroundTransparency = 0.7
    glow.BorderSizePixel = 0
    glow.ZIndex = 0
    glow.Parent = card
    
    createCorner(glow, 14)
    
    local logo = Instance.new("TextLabel")
    logo.Size = UDim2.new(0, 50, 0, 50)
    logo.Position = UDim2.new(0, 8, 0.5, -25)
    logo.BackgroundTransparency = 1
    logo.Text = "$"
    logo.TextColor3 = CONFIG.Colors.Primary
    logo.TextSize = 36
    logo.Font = Enum.Font.GothamBold
    logo.Parent = card
    
    local typingText = Instance.new("TextLabel")
    typingText.Size = UDim2.new(1, -68, 0, 25)
    typingText.Position = UDim2.new(0, 63, 0, 8)
    typingText.BackgroundTransparency = 1
    typingText.Text = ""
    typingText.TextColor3 = CONFIG.Colors.Text
    typingText.TextSize = 18
    typingText.Font = Enum.Font.GothamBold
    typingText.TextXAlignment = Enum.TextXAlignment.Left
    typingText.Parent = card
    
    local infoText = Instance.new("TextLabel")
    infoText.Size = UDim2.new(1, -68, 0, 20)
    infoText.Position = UDim2.new(0, 63, 0, 35)
    infoText.BackgroundTransparency = 1
    infoText.Text = playerInfo.executor .. " | " .. playerInfo.device
    infoText.TextColor3 = CONFIG.Colors.TextSecondary
    infoText.TextSize = 13
    infoText.Font = Enum.Font.GothamMedium
    infoText.TextXAlignment = Enum.TextXAlignment.Left
    infoText.Parent = card
    
    local usernameText = Instance.new("TextLabel")
    usernameText.Size = UDim2.new(1, -68, 0, 18)
    usernameText.Position = UDim2.new(0, 63, 0, 55)
    usernameText.BackgroundTransparency = 1
    usernameText.Text = "@" .. targetPlayer.Name
    usernameText.TextColor3 = CONFIG.Colors.Primary
    usernameText.TextSize = 14
    usernameText.Font = Enum.Font.GothamBold
    usernameText.TextXAlignment = Enum.TextXAlignment.Left
    usernameText.TextTruncate = Enum.TextTruncate.AtEnd
    usernameText.Parent = card
    
    local fullText = "$errated User"
    local cursorVisible = true
    
    local function typeText()
        while typingText and typingText.Parent and scriptActive do
            for i = 1, #fullText do
                if not typingText or not typingText.Parent or not scriptActive then break end
                typingText.Text = fullText:sub(1, i) .. "|"
                wait(0.08)
            end
            
            for i = 1, 6 do
                if not typingText or not typingText.Parent or not scriptActive then break end
                cursorVisible = not cursorVisible
                typingText.Text = fullText .. (cursorVisible and "|" or "")
                wait(0.5)
            end
            
            wait(0.5)
        end
    end
    
    spawn(typeText)
    
    spawn(function()
        while glow and glow.Parent and scriptActive do
            smoothTween(glow, {BackgroundTransparency = 0.9}, 1)
            wait(1)
            if not scriptActive then break end
            smoothTween(glow, {BackgroundTransparency = 0.7}, 1)
            wait(1)
        end
    end)
    
    card.Size = UDim2.new(0, 0, 0, 0)
    card.Position = UDim2.new(0.5, 0, 0.5, 0)
    card.AnchorPoint = Vector2.new(0.5, 0.5)
    
    smoothTween(card, {
        Size = UDim2.new(1, 0, 1, 0),
        Position = UDim2.new(0.5, 0, 0.5, 0)
    }, 0.6)
end

-- Monitor script users
local function monitorScriptUsers()
    RunService.Heartbeat:Connect(function()
        if not scriptActive then return end
        for _, targetPlayer in ipairs(Players:GetPlayers()) do
            if isScriptUser(targetPlayer) then
                if not scriptUsers[targetPlayer.UserId] then
                    scriptUsers[targetPlayer.UserId] = true
                    if targetPlayer.Character and targetPlayer.Character:FindFirstChild("Head") then
                        if not targetPlayer.Character.Head:FindFirstChild("UserCard") then
                            createUserCard(targetPlayer)
                        end
                    end
                end
            else
                if scriptUsers[targetPlayer.UserId] then
                    scriptUsers[targetPlayer.UserId] = nil
                    if targetPlayer.Character and targetPlayer.Character:FindFirstChild("Head") then
                        local card = targetPlayer.Character.Head:FindFirstChild("UserCard")
                        if card then card:Destroy() end
                    end
                end
            end
        end
    end)
end

-- FPS Counter
local fps = 0
local lastUpdate = tick()
RunService.RenderStepped:Connect(function()
    if not scriptActive then return end
    local now = tick()
    fps = math.floor(1 / (now - lastUpdate))
    lastUpdate = now
end)

-- Draggable Toggle Button (IMPROVED STYLING)
local toggleButton = Instance.new("TextButton")
toggleButton.Size = UDim2.new(0, 220, 0, 70)
toggleButton.Position = UDim2.new(1, -240, 1, -90)
toggleButton.BackgroundColor3 = CONFIG.Colors.Background
toggleButton.BorderSizePixel = 0
toggleButton.Text = ""
toggleButton.Active = true
toggleButton.Draggable = true
toggleButton.Parent = screenGui

createCorner(toggleButton, 14)
local buttonStroke = createStroke(toggleButton, 2)
buttonStroke.Transparency = 0 -- Visible outline
createGradient(toggleButton, 135)

-- Add glow effect similar to overhead card
local buttonGlow = Instance.new("Frame")
buttonGlow.Size = UDim2.new(1, 4, 1, 4)
buttonGlow.Position = UDim2.new(0, -2, 0, -2)
buttonGlow.BackgroundColor3 = CONFIG.Colors.Primary
buttonGlow.BackgroundTransparency = 0.7
buttonGlow.BorderSizePixel = 0
buttonGlow.ZIndex = 0
buttonGlow.Parent = toggleButton

createCorner(buttonGlow, 14)

-- Animate button glow
spawn(function()
    while wait(1) and scriptActive do
        if buttonGlow and buttonGlow.Parent then
            smoothTween(buttonGlow, {BackgroundTransparency = 0.9}, 1)
            wait(1)
            if not scriptActive then break end
            smoothTween(buttonGlow, {BackgroundTransparency = 0.7}, 1)
        end
    end
end)

local buttonLogo = Instance.new("TextLabel")
buttonLogo.Size = UDim2.new(0, 50, 1, 0)
buttonLogo.Position = UDim2.new(0, 10, 0, 0)
buttonLogo.BackgroundTransparency = 1
buttonLogo.Text = "$"
buttonLogo.TextColor3 = CONFIG.Colors.Primary
buttonLogo.TextSize = 36
buttonLogo.Font = Enum.Font.GothamBold
buttonLogo.ZIndex = 2
buttonLogo.Parent = toggleButton

local infoContainer = Instance.new("Frame")
infoContainer.Size = UDim2.new(1, -70, 1, 0)
infoContainer.Position = UDim2.new(0, 65, 0, 0)
infoContainer.BackgroundTransparency = 1
infoContainer.ZIndex = 2
infoContainer.Parent = toggleButton

local fpsLabel = Instance.new("TextLabel")
fpsLabel.Size = UDim2.new(1, 0, 0, 25)
fpsLabel.Position = UDim2.new(0, 0, 0, 8)
fpsLabel.BackgroundTransparency = 1
fpsLabel.Text = "FPS: 60"
fpsLabel.TextColor3 = CONFIG.Colors.Success
fpsLabel.TextSize = 18
fpsLabel.Font = Enum.Font.GothamBold
fpsLabel.TextXAlignment = Enum.TextXAlignment.Left
fpsLabel.Parent = infoContainer

local executorLabel = Instance.new("TextLabel")
executorLabel.Size = UDim2.new(1, 0, 0, 20)
executorLabel.Position = UDim2.new(0, 0, 0, 35)
executorLabel.BackgroundTransparency = 1
executorLabel.Text = EXECUTOR
executorLabel.TextColor3 = CONFIG.Colors.TextSecondary
executorLabel.TextSize = 14
executorLabel.Font = Enum.Font.GothamMedium
executorLabel.TextXAlignment = Enum.TextXAlignment.Left
executorLabel.Parent = infoContainer

spawn(function()
    while wait(0.5) do
        if not scriptActive then break end
        if fpsLabel then
            fpsLabel.Text = "FPS: " .. fps
            if fps >= 50 then
                fpsLabel.TextColor3 = CONFIG.Colors.Success
            elseif fps >= 30 then
                fpsLabel.TextColor3 = Color3.fromRGB(255, 200, 0)
            else
                fpsLabel.TextColor3 = CONFIG.Colors.Error
            end
        end
    end
end)

-- Main Menu UI
local mainFrame = Instance.new("Frame")
mainFrame.Name = "CommandMenu"
mainFrame.Size = UDim2.new(0, 750, 0, 600)
mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
mainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
mainFrame.BackgroundColor3 = CONFIG.Colors.Background
mainFrame.BorderSizePixel = 0
mainFrame.Visible = false
mainFrame.Parent = screenGui

createCorner(mainFrame, 20)
createStroke(mainFrame, 3)

local header = Instance.new("Frame")
header.Size = UDim2.new(1, 0, 0, 70)
header.BackgroundColor3 = CONFIG.Colors.BackgroundTransparent
header.BorderSizePixel = 0
header.Parent = mainFrame

createCorner(header, 20)
createGradient(header, 90)

local headerLogo = Instance.new("TextLabel")
headerLogo.Size = UDim2.new(0, 60, 1, 0)
headerLogo.Position = UDim2.new(0, 15, 0, 0)
headerLogo.BackgroundTransparency = 1
headerLogo.Text = "$"
headerLogo.TextColor3 = CONFIG.Colors.Primary
headerLogo.TextSize = 42
headerLogo.Font = Enum.Font.GothamBold
headerLogo.Parent = header

local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, -90, 1, 0)
title.Position = UDim2.new(0, 75, 0, 0)
title.BackgroundTransparency = 1
title.Text = "Command Menu"
title.TextColor3 = CONFIG.Colors.Text
title.TextSize = 24
title.Font = Enum.Font.GothamBold
title.TextXAlignment = Enum.TextXAlignment.Left
title.Parent = header

local closeButton = Instance.new("TextButton")
closeButton.Size = UDim2.new(0, 40, 0, 40)
closeButton.Position = UDim2.new(1, -55, 0, 15)
closeButton.BackgroundColor3 = CONFIG.Colors.BackgroundTransparent
closeButton.BorderSizePixel = 0
closeButton.Text = "×"
closeButton.TextColor3 = CONFIG.Colors.Text
closeButton.TextSize = 32
closeButton.Font = Enum.Font.GothamBold
closeButton.Parent = header

createCorner(closeButton, 10)

local inputFrame = Instance.new("Frame")
inputFrame.Size = UDim2.new(1, -40, 0, 60)
inputFrame.Position = UDim2.new(0, 20, 0, 90)
inputFrame.BackgroundColor3 = CONFIG.Colors.BackgroundTransparent
inputFrame.BorderSizePixel = 0
inputFrame.Parent = mainFrame

createCorner(inputFrame, 12)
createStroke(inputFrame, 2)

local commandInput = Instance.new("TextBox")
commandInput.Size = UDim2.new(1, -20, 1, -20)
commandInput.Position = UDim2.new(0, 10, 0, 10)
commandInput.BackgroundTransparency = 1
commandInput.PlaceholderText = "Enter command (type !help for list)..."
commandInput.PlaceholderColor3 = CONFIG.Colors.TextSecondary
commandInput.Text = ""
commandInput.TextColor3 = CONFIG.Colors.Text
commandInput.TextSize = 18
commandInput.Font = Enum.Font.GothamMedium
commandInput.TextXAlignment = Enum.TextXAlignment.Left
commandInput.ClearTextOnFocus = false
commandInput.ZIndex = 2
commandInput.Parent = inputFrame

-- Autocomplete Suggestion Label
local suggestionLabel = Instance.new("TextLabel")
suggestionLabel.Size = UDim2.new(1, -20, 1, -20)
suggestionLabel.Position = UDim2.new(0, 10, 0, 10)
suggestionLabel.BackgroundTransparency = 1
suggestionLabel.Text = ""
suggestionLabel.TextColor3 = CONFIG.Colors.Suggestion
suggestionLabel.TextTransparency = 0.5
suggestionLabel.TextSize = 18
suggestionLabel.Font = Enum.Font.GothamMedium
suggestionLabel.TextXAlignment = Enum.TextXAlignment.Left
suggestionLabel.ZIndex = 1
suggestionLabel.Parent = inputFrame

-- Autocomplete Logic
local function updateSuggestion()
    local input = commandInput.Text
    suggestionLabel.Text = ""
    
    if input == "" or not input:match("^!") then
        return
    end
    
    local args = {}
    for word in input:gmatch("%S+") do
        table.insert(args, word)
    end
    
    local baseCmd = args[1]:lower()
    
    -- Find matching command
    for _, cmdData in ipairs(commandList) do
        if cmdData.cmd:lower():find("^" .. baseCmd:lower()) and cmdData.cmd:lower() ~= baseCmd:lower() then
            if #args == 1 then
                suggestionLabel.Text = cmdData.cmd
                return
            end
        end
    end
    
    -- Check if command needs username
    for _, cmdData in ipairs(commandList) do
        if cmdData.cmd:lower() == baseCmd:lower() then
            if cmdData.requiresUsername and #args == 1 then
                suggestionLabel.Text = input .. " @username"
                return
            elseif cmdData.requiresNumber and #args == 1 then
                suggestionLabel.Text = input .. " [number]"
                return
            end
        end
    end
end

commandInput:GetPropertyChangedSignal("Text"):Connect(updateSuggestion)

local scrollFrame = Instance.new("ScrollingFrame")
scrollFrame.Size = UDim2.new(1, -40, 1, -180)
scrollFrame.Position = UDim2.new(0, 20, 0, 170)
scrollFrame.BackgroundColor3 = CONFIG.Colors.BackgroundTransparent
scrollFrame.BorderSizePixel = 0
scrollFrame.ScrollBarThickness = 6
scrollFrame.ScrollBarImageColor3 = CONFIG.Colors.Primary
scrollFrame.Parent = mainFrame

createCorner(scrollFrame, 12)

local infoLabel = Instance.new("TextLabel")
infoLabel.Size = UDim2.new(1, -20, 0, 2000)
infoLabel.Position = UDim2.new(0, 10, 0, 10)
infoLabel.BackgroundTransparency = 1
infoLabel.Text = [[Available Commands:

MOVEMENT:
!fly - Professional admin fly (WASD to move, Space/Shift for up/down)
!unfly - Disable flying
!flyspeed [number] - Set fly speed (default: 50)
!rsfly - Reset fly speed

!smfly / !superman - Superman fly with animations
!unsmfly / !unsuperman - Disable superman fly
!smspeed [number] - Set superman fly speed
!rssm - Reset superman speed

!noclip / !clip - Walk through walls
!unnoclip / !unclip - Disable noclip

!float - Float mode (Q to go up, E to go down)
!unfloat - Disable floating

!infj / !infinitejump - Infinite jumping
!uninfj / !uninfinitejump - Disable infinite jump

TELEPORT:
!tp [username] / !goto [username] - Teleport to a player
!bring [username] - Bring player to you
!tptool - Get click-to-teleport tool

STATS:
!ws [number] / !walkspeed [number] - Set walk speed
!resetws - Reset to original walk speed
!jp [number] / !jumppower [number] - Set jump power  
!resetjp - Reset to original jump power
!gravity [number] - Set workspace gravity
!resetgravity - Reset gravity to default

AVATAR:
!char [username] - Load any player's avatar
!invisible - Become invisible
!visible - Become visible again

FUN:
!spin - Spin your character
!unspin - Stop spinning
!spinspeed [number] - Set spin speed

CHAT & PROTECTION:
!cb / !chatbypass - Toggle chat filter bypass
!antiafk / !antiidle - Toggle anti-AFK (prevents kick for idling)
!antivcban / !antivcb / !novcb - Toggle anti-VC-ban protection

SERVER:
!rejoin / !rj - Rejoin the same server (auto-reexecutes script)
!serverhop / !shop - Server hop to a different server (auto-reexecutes)
!join [username] - Join a specific user's server

UTILITY:
!update / !updt - Update to latest script version
!users - List all script users in server
!unexecute - Completely remove the script
!help - Show this command list

TIP: Start typing a command to see autocomplete suggestions!
Auto-reexecution is enabled for rejoin/serverhop commands.]]
infoLabel.TextColor3 = CONFIG.Colors.TextSecondary
infoLabel.TextSize = 15
infoLabel.Font = Enum.Font.GothamMedium
infoLabel.TextXAlignment = Enum.TextXAlignment.Left
infoLabel.TextYAlignment = Enum.TextYAlignment.Top
infoLabel.Parent = scrollFrame

scrollFrame.CanvasSize = UDim2.new(0, 0, 0, infoLabel.TextBounds.Y + 20)

-- COMMAND IMPLEMENTATIONS

local function findPlayer(name)
    name = name:lower()
    for _, p in ipairs(Players:GetPlayers()) do
        if p.Name:lower():find(name) or p.DisplayName:lower():find(name) then
            return p
        end
    end
    return nil
end

-- FIXED PROFESSIONAL FLY (Stable, no bugs)
local flyPart = nil
local bodyVel = nil
local bodyGyro = nil

local function enableFly()
    if commandStates.flying then
        showNotification("Fly is already enabled!", "error")
        return
    end
    
    commandStates.flying = true
    
    -- Create fly platform
    flyPart = Instance.new("Part")
    flyPart.Name = "FlyPart"
    flyPart.Anchored = true
    flyPart.Transparency = 1
    flyPart.CanCollide = false
    flyPart.Size = Vector3.new(4, 0.5, 2)
    flyPart.Parent = workspace
    
    -- Create body movers for smooth movement
    bodyVel = Instance.new("BodyVelocity")
    bodyVel.Velocity = Vector3.new(0, 0, 0)
    bodyVel.MaxForce = Vector3.new(100000, 100000, 100000)
    bodyVel.P = 10000
    bodyVel.Parent = character.HumanoidRootPart
    
    bodyGyro = Instance.new("BodyGyro")
    bodyGyro.MaxTorque = Vector3.new(100000, 100000, 100000)
    bodyGyro.P = 10000
    bodyGyro.D = 500
    bodyGyro.Parent = character.HumanoidRootPart
    
    -- Disable certain humanoid states
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Freefall, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Flying, true)
    humanoid:ChangeState(Enum.HumanoidStateType.Flying)
    
    activeConnections.fly = RunService.Heartbeat:Connect(function()
        if not commandStates.flying or not character or not character:FindFirstChild("HumanoidRootPart") then
            if flyPart then flyPart:Destroy() end
            if bodyVel then bodyVel:Destroy() end
            if bodyGyro then bodyGyro:Destroy() end
            return
        end
        
        local hrp = character.HumanoidRootPart
        local camera = workspace.CurrentCamera
        local moveVector = Vector3.new(0, 0, 0)
        
        -- Calculate movement direction
        if UserInputService:IsKeyDown(Enum.KeyCode.W) then
            moveVector = moveVector + (camera.CFrame.LookVector)
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then
            moveVector = moveVector - (camera.CFrame.LookVector)
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.A) then
            moveVector = moveVector - (camera.CFrame.RightVector)
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.D) then
            moveVector = moveVector + (camera.CFrame.RightVector)
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
            moveVector = moveVector + Vector3.new(0, 1, 0)
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
            moveVector = moveVector - Vector3.new(0, 1, 0)
        end
        
        -- Normalize and apply speed
        if moveVector.Magnitude > 0 then
            moveVector = moveVector.Unit * commandStates.flySpeed
        end
        
        -- Update body movers
        bodyVel.Velocity = moveVector
        bodyGyro.CFrame = camera.CFrame
        
        -- Update platform position
        flyPart.CFrame = hrp.CFrame * CFrame.new(0, -3.5, 0)
    end)
    
    showNotification("Professional fly enabled!", "success")
end

local function disableFly()
    if not commandStates.flying then
        showNotification("Fly is not enabled!", "error")
        return
    end
    
    commandStates.flying = false
    
    if activeConnections.fly then
        activeConnections.fly:Disconnect()
        activeConnections.fly = nil
    end
    
    if flyPart then
        flyPart:Destroy()
        flyPart = nil
    end
    
    if bodyVel then
        bodyVel:Destroy()
        bodyVel = nil
    end
    
    if bodyGyro then
        bodyGyro:Destroy()
        bodyGyro = nil
    end
    
    -- Re-enable humanoid states
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Freefall, true)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
    humanoid:ChangeState(Enum.HumanoidStateType.Freefall)
    
    showNotification("Fly disabled!", "success")
end

-- SUPERMAN FLY
local supermanAnim = nil
local function enableSupermanFly()
    if commandStates.supermanFly then
        showNotification("Superman fly is already enabled!", "error")
        return
    end
    
    commandStates.supermanFly = true
    
    local bodyGyro = Instance.new("BodyGyro")
    bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
    bodyGyro.P = 9000
    bodyGyro.Parent = character.HumanoidRootPart
    
    local bodyVel = Instance.new("BodyVelocity")
    bodyVel.Velocity = Vector3.new(0, 0, 0)
    bodyVel.MaxForce = Vector3.new(9e9, 9e9, 9e9)
    bodyVel.Parent = character.HumanoidRootPart
    
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Freefall, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
    
    local idleAnim = Instance.new("Animation")
    idleAnim.AnimationId = "rbxassetid://104879320142507"
    
    local moveAnim = Instance.new("Animation")
    moveAnim.AnimationId = "rbxassetid://140087168717341"
    
    local idleTrack = humanoid:LoadAnimation(idleAnim)
    local moveTrack = humanoid:LoadAnimation(moveAnim)
    
    idleTrack.Priority = Enum.AnimationPriority.Action4
    moveTrack.Priority = Enum.AnimationPriority.Action4
    
    idleTrack:Play()
    supermanAnim = {idle = idleTrack, move = moveTrack, current = "idle"}
    
    activeConnections.supermanFly = RunService.Heartbeat:Connect(function()
        if not commandStates.supermanFly or not scriptActive then
            if bodyGyro then bodyGyro:Destroy() end
            if bodyVel then bodyVel:Destroy() end
            if supermanAnim then
                supermanAnim.idle:Stop()
                supermanAnim.move:Stop()
            end
            humanoid:SetStateEnabled(Enum.HumanoidStateType.Freefall, true)
            humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
            return
        end
        
        local camera = workspace.CurrentCamera
        local moveVector = Vector3.new(0, 0, 0)
        local horizontalMove = false
        
        if UserInputService:IsKeyDown(Enum.KeyCode.W) then
            moveVector = moveVector + (camera.CFrame.LookVector * commandStates.supermanSpeed)
            horizontalMove = true
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then
            moveVector = moveVector - (camera.CFrame.LookVector * commandStates.supermanSpeed)
            horizontalMove = true
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.A) then
            moveVector = moveVector - (camera.CFrame.RightVector * commandStates.supermanSpeed)
            horizontalMove = true
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.D) then
            moveVector = moveVector + (camera.CFrame.RightVector * commandStates.supermanSpeed)
            horizontalMove = true
        end
        
        if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
            moveVector = moveVector + Vector3.new(0, commandStates.supermanSpeed, 0)
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
            moveVector = moveVector - Vector3.new(0, commandStates.supermanSpeed, 0)
        end
        
        bodyVel.Velocity = moveVector
        bodyGyro.CFrame = camera.CFrame
        
        if horizontalMove then
            if supermanAnim.current ~= "move" then
                supermanAnim.idle:Stop()
                supermanAnim.move:Play()
                supermanAnim.current = "move"
            end
        else
            if supermanAnim.current ~= "idle" then
                supermanAnim.move:Stop()
                supermanAnim.idle:Play()
                supermanAnim.current = "idle"
            end
        end
    end)
    
    showNotification("Superman fly enabled!", "success")
end

local function disableSupermanFly()
    if not commandStates.supermanFly then
        showNotification("Superman fly is not enabled!", "error")
        return
    end
    
    commandStates.supermanFly = false
    
    if activeConnections.supermanFly then
        activeConnections.supermanFly:Disconnect()
        activeConnections.supermanFly = nil
    end
    
    if supermanAnim then
        supermanAnim.idle:Stop()
        supermanAnim.move:Stop()
        supermanAnim = nil
    end
    
    local bodyGyro = character.HumanoidRootPart:FindFirstChild("BodyGyro")
    local bodyVel = character.HumanoidRootPart:FindFirstChild("BodyVelocity")
    if bodyGyro then bodyGyro:Destroy() end
    if bodyVel then bodyVel:Destroy() end
    
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Freefall, true)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
    
    showNotification("Superman fly disabled!", "success")
end

-- NOCLIP
local function enableNoclip()
    if commandStates.noclip then
        showNotification("Noclip is already enabled!", "error")
        return
    end
    
    commandStates.noclip = true
    
    activeConnections.noclip = RunService.Stepped:Connect(function()
        if not commandStates.noclip or not scriptActive then return end
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end)
    
    showNotification("Noclip enabled!", "success")
end

local function disableNoclip()
    if not commandStates.noclip then
        showNotification("Noclip is not enabled!", "error")
        return
    end
    
    commandStates.noclip = false
    
    if activeConnections.noclip then
        activeConnections.noclip:Disconnect()
        activeConnections.noclip = nil
    end
    
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            part.CanCollide = true
        end
    end
    
    showNotification("Noclip disabled!", "success")
end

-- FLOAT
local floatHeight = 0
local function enableFloat()
    if commandStates.float then
        showNotification("Float is already enabled!", "error")
        return
    end
    
    commandStates.float = true
    floatHeight = 0
    
    local floatPart = Instance.new("Part")
    floatPart.Name = "FloatPart"
    floatPart.Size = Vector3.new(6, 0.5, 6)
    floatPart.Transparency = 1
    floatPart.Anchored = true
    floatPart.CanCollide = true
    floatPart.Parent = workspace
    
    activeConnections.float = RunService.Heartbeat:Connect(function()
        if not commandStates.float or not scriptActive then
            if floatPart then floatPart:Destroy() end
            return
        end
        
        floatPart.CFrame = character.HumanoidRootPart.CFrame * CFrame.new(0, -3.5 + floatHeight, 0)
    end)
    
    activeConnections.floatUp = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed or not commandStates.float or not scriptActive then return end
        if input.KeyCode == Enum.KeyCode.Q then
            floatHeight = floatHeight + 0.5
        end
    end)
    
    activeConnections.floatDown = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed or not commandStates.float or not scriptActive then return end
        if input.KeyCode == Enum.KeyCode.E then
            floatHeight = floatHeight - 0.5
        end
    end)
    
    showNotification("Float enabled! Press Q/E to go up/down", "success")
end

local function disableFloat()
    if not commandStates.float then
        showNotification("Float is not enabled!", "error")
        return
    end
    
    commandStates.float = false
    floatHeight = 0
    
    if activeConnections.float then
        activeConnections.float:Disconnect()
        activeConnections.float = nil
    end
    
    if activeConnections.floatUp then
        activeConnections.floatUp:Disconnect()
        activeConnections.floatUp = nil
    end
    
    if activeConnections.floatDown then
        activeConnections.floatDown:Disconnect()
        activeConnections.floatDown = nil
    end
    
    local floatPart = workspace:FindFirstChild("FloatPart")
    if floatPart then floatPart:Destroy() end
    
    showNotification("Float disabled!", "success")
end

-- INFINITE JUMP
local function enableInfiniteJump()
    if commandStates.infiniteJump then
        showNotification("Infinite jump is already enabled!", "error")
        return
    end
    
    commandStates.infiniteJump = true
    
    activeConnections.infiniteJump = UserInputService.JumpRequest:Connect(function()
        if commandStates.infiniteJump and humanoid and scriptActive then
            humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end
    end)
    
    showNotification("Infinite jump enabled!", "success")
end

local function disableInfiniteJump()
    if not commandStates.infiniteJump then
        showNotification("Infinite jump is not enabled!", "error")
        return
    end
    
    commandStates.infiniteJump = false
    
    if activeConnections.infiniteJump then
        activeConnections.infiniteJump:Disconnect()
        activeConnections.infiniteJump = nil
    end
    
    showNotification("Infinite jump disabled!", "success")
end

-- TELEPORT
local function teleportToPlayer(targetName)
    local targetPlayer = findPlayer(targetName)
    
    if not targetPlayer then
        showNotification('Player "' .. targetName .. '" not found!', "error")
        return
    end
    
    if not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
        showNotification("Target player has no character!", "error")
        return
    end
    
    character.HumanoidRootPart.CFrame = targetPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(0, 0, 3)
    showNotification("Teleported to " .. targetPlayer.Name .. "!", "success")
end

-- BRING PLAYER
local function bringPlayer(targetName)
    local targetPlayer = findPlayer(targetName)
    
    if not targetPlayer then
        showNotification('Player "' .. targetName .. '" not found!', "error")
        return
    end
    
    if not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
        showNotification("Target player has no character!", "error")
        return
    end
    
    targetPlayer.Character.HumanoidRootPart.CFrame = character.HumanoidRootPart.CFrame * CFrame.new(0, 0, 3)
    showNotification("Brought " .. targetPlayer.Name .. " to you!", "success")
end

-- TP TOOL
local function createTpTool()
    local tool = Instance.new("Tool")
    tool.Name = "$errated TP Tool"
    tool.RequiresHandle = false
    tool.CanBeDropped = false
    
    tool.Activated:Connect(function()
        local targetPos = mouse.Hit.Position
        if character and character:FindFirstChild("HumanoidRootPart") then
            character.HumanoidRootPart.CFrame = CFrame.new(targetPos + Vector3.new(0, 3, 0))
        end
    end)
    
    tool.Parent = player.Backpack
    showNotification("TP Tool added to inventory!", "success")
end

-- STATS
local function setWalkSpeed(speed)
    local speedNum = tonumber(speed)
    if not speedNum then
        showNotification("Invalid speed value!", "error")
        return
    end
    
    humanoid.WalkSpeed = speedNum
    showNotification("Walk speed set to " .. speedNum, "success")
end

local function resetWalkSpeed()
    humanoid.WalkSpeed = commandStates.originalWalkSpeed
    showNotification("Walk speed reset!", "success")
end

local function setJumpPower(power)
    local powerNum = tonumber(power)
    if not powerNum then
        showNotification("Invalid jump power value!", "error")
        return
    end
    
    if humanoid.UseJumpPower then
        humanoid.JumpPower = powerNum
    else
        humanoid.JumpHeight = powerNum / 3.5
    end
    showNotification("Jump power set to " .. powerNum, "success")
end

local function resetJumpPower()
    if humanoid.UseJumpPower then
        humanoid.JumpPower = commandStates.originalJumpPower
    else
        humanoid.JumpHeight = commandStates.originalJumpPower / 3.5
    end
    showNotification("Jump power reset!", "success")
end

local function setGravity(grav)
    local gravNum = tonumber(grav)
    if not gravNum then
        showNotification("Invalid gravity value!", "error")
        return
    end
    
    workspace.Gravity = gravNum
    showNotification("Gravity set to " .. gravNum, "success")
end

local function resetGravity()
    workspace.Gravity = commandStates.originalGravity
    showNotification("Gravity reset to " .. commandStates.originalGravity .. "!", "success")
end

-- AVATAR
local function loadCharacter(username)
    showNotification("Loading " .. username .. "'s avatar...", "info")
    
    local success, userId = pcall(function()
        return Players:GetUserIdFromNameAsync(username)
    end)
    
    if not success or not userId then
        showNotification('Player "' .. username .. '" not found!', "error")
        return
    end
    
    local method1Success = pcall(function()
        local description = Players:GetHumanoidDescriptionFromUserId(userId)
        if description and humanoid then
            for _, item in pairs(character:GetChildren()) do
                if item:IsA("Accessory") or item:IsA("Hat") or item:IsA("Shirt") or item:IsA("Pants") or item:IsA("ShirtGraphic") then
                    item:Destroy()
                end
            end
            
            humanoid:ApplyDescription(description)
            showNotification("Loaded " .. username .. "'s avatar!", "success")
            return true
        end
        return false
    end)
    
    if method1Success then return end
    
    pcall(function()
        for _, item in pairs(character:GetChildren()) do
            if item:IsA("Accessory") or item:IsA("Hat") or item:IsA("Shirt") or item:IsA("Pants") or item:IsA("ShirtGraphic") then
                item:Destroy()
            end
        end
        
        local tempModel = Players:GetCharacterAppearanceAsync(userId)
        
        for _, item in pairs(tempModel:GetChildren()) do
            if item:IsA("Accessory") or item:IsA("Hat") or item:IsA("Shirt") or item:IsA("Pants") or item:IsA("ShirtGraphic") or item:IsA("BodyColors") then
                local clone = item:Clone()
                clone.Parent = character
            end
        end
        
        tempModel:Destroy()
        showNotification("Loaded " .. username .. "'s avatar!", "success")
    end)
end

-- INVISIBILITY
local originalTransparencies = {}
local function makeInvisible()
    if commandStates.invisible then
        showNotification("Already invisible!", "error")
        return
    end
    
    commandStates.invisible = true
    
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") or part:IsA("Decal") then
            originalTransparencies[part] = part.Transparency
            part.Transparency = 1
        end
    end
    
    showNotification("You are now invisible!", "success")
end

local function makeVisible()
    if not commandStates.invisible then
        showNotification("Not invisible!", "error")
        return
    end
    
    commandStates.invisible = false
    
    for part, transparency in pairs(originalTransparencies) do
        if part and part.Parent then
            part.Transparency = transparency
        end
    end
    
    originalTransparencies = {}
    showNotification("You are now visible!", "success")
end

-- SPIN
local function enableSpin()
    if commandStates.spinning then
        showNotification("Already spinning!", "error")
        return
    end
    
    commandStates.spinning = true
    
    local spinGyro = Instance.new("BodyGyro")
    spinGyro.Name = "SpinGyro"
    spinGyro.MaxTorque = Vector3.new(0, math.huge, 0)
    spinGyro.P = 10000
    spinGyro.Parent = character.HumanoidRootPart
    
    activeConnections.spin = RunService.Heartbeat:Connect(function()
        if not commandStates.spinning or not scriptActive then
            if spinGyro then spinGyro:Destroy() end
            return
        end
        
        spinGyro.CFrame = spinGyro.CFrame * CFrame.Angles(0, math.rad(commandStates.spinSpeed), 0)
    end)
    
    showNotification("Spinning enabled!", "success")
end

local function disableSpin()
    if not commandStates.spinning then
        showNotification("Not spinning!", "error")
        return
    end
    
    commandStates.spinning = false
    
    if activeConnections.spin then
        activeConnections.spin:Disconnect()
        activeConnections.spin = nil
    end
    
    local spinGyro = character.HumanoidRootPart:FindFirstChild("SpinGyro")
    if spinGyro then spinGyro:Destroy() end
    
    showNotification("Spinning disabled!", "success")
end

-- CHAT BYPASS
local function toggleChatBypass()
    commandStates.chatBypass = not commandStates.chatBypass
    
    if commandStates.chatBypass then
        if activeConnections.chatBypass then
            activeConnections.chatBypass:Disconnect()
        end
        
        local oldNamecall
        oldNamecall = hookmetamethod(game, "__namecall", function(self, ...)
            local args = {...}
            local method = getnamecallmethod()
            
            if method == "FireServer" and self.Name == "SayMessageRequest" then
                local message = args[1]
                local bypassedMessage = ""
                
                for i = 1, #message do
                    local char = message:sub(i, i)
                    bypassedMessage = bypassedMessage .. (bypassChars[char] or char)
                end
                
                args[1] = bypassedMessage
                return oldNamecall(self, unpack(args))
            end
            
            return oldNamecall(self, ...)
        end)
        
        activeConnections.chatBypass = {Disconnect = function()
            hookmetamethod(game, "__namecall", oldNamecall)
        end}
        
        showNotification("Chat bypass enabled!", "success")
    else
        if activeConnections.chatBypass then
            activeConnections.chatBypass:Disconnect()
            activeConnections.chatBypass = nil
        end
        showNotification("Chat bypass disabled!", "success")
    end
end

-- ANTI-AFK
local function toggleAntiAfk()
    commandStates.antiAfk = not commandStates.antiAfk
    
    if commandStates.antiAfk then
        activeConnections.antiAfk = player.Idled:Connect(function()
            VirtualUser:CaptureController()
            VirtualUser:ClickButton2(Vector2.new())
        end)
        showNotification("Anti-AFK enabled!", "success")
    else
        if activeConnections.antiAfk then
            activeConnections.antiAfk:Disconnect()
            activeConnections.antiAfk = nil
        end
        showNotification("Anti-AFK disabled!", "success")
    end
end

-- ANTI-VC-BAN
local function toggleAntiVcBan()
    commandStates.antiVcBan = not commandStates.antiVcBan
    
    if commandStates.antiVcBan then
        local function blockVcBan()
            for _, v in pairs(game:GetDescendants()) do
                if v:IsA("RemoteEvent") or v:IsA("RemoteFunction") then
                    if v.Name:lower():find("voice") or v.Name:lower():find("chat") or v.Name:lower():find("ban") then
                        pcall(function()
                            v:Destroy()
                        end)
                    end
                end
            end
        end
        
        blockVcBan()
        
        game.DescendantAdded:Connect(function(v)
            if not commandStates.antiVcBan then return end
            if v:IsA("RemoteEvent") or v:IsA("RemoteFunction") then
                if v.Name:lower():find("voice") or v.Name:lower():find("chat") or v.Name:lower():find("ban") then
                    wait()
                    pcall(function()
                        v:Destroy()
                    end)
                end
            end
        end)
        
        showNotification("Anti-VC-Ban enabled!", "success")
    else
        showNotification("Anti-VC-Ban disabled!", "success")
    end
end

-- SERVER MANAGEMENT (WITH AUTO-REEXEC)
local function rejoinServer()
    showNotification("Rejoining server...", "info")
    _G[AUTO_REEXEC_FLAG] = true
    wait(0.5)
    TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, player)
end

local function serverHop()
    showNotification("Finding new server...", "info")
    
    local success, servers = pcall(function()
        return HttpService:JSONDecode(game:HttpGet("https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"))
    end)
    
    if success and servers and servers.data then
        local validServers = {}
        for _, server in pairs(servers.data) do
            if server.id ~= game.JobId and server.playing < server.maxPlayers then
                table.insert(validServers, server)
            end
        end
        
        if #validServers > 0 then
            local randomServer = validServers[math.random(1, #validServers)]
            _G[AUTO_REEXEC_FLAG] = true
            wait(0.5)
            TeleportService:TeleportToPlaceInstance(game.PlaceId, randomServer.id, player)
        else
            showNotification("No available servers found!", "error")
        end
    else
        showNotification("Failed to fetch servers!", "error")
    end
end

local function joinUser(username)
    showNotification("Finding " .. username .. "'s server...", "info")
    
    local success, userId = pcall(function()
        return Players:GetUserIdFromNameAsync(username)
    end)
    
    if not success or not userId then
        showNotification('Player "' .. username .. '" not found!', "error")
        return
    end
    
    _G[AUTO_REEXEC_FLAG] = true
    wait(0.5)
    pcall(function()
        TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, player)
    end)
end

-- LIST USERS
local function listScriptUsers()
    local userList = {}
    for _, p in ipairs(Players:GetPlayers()) do
        if isScriptUser(p) and p ~= player then
            local info = getPlayerInfo(p)
            table.insert(userList, p.Name .. " (" .. info.executor .. " | " .. info.device .. ")")
        end
    end
    
    if #userList == 0 then
        showNotification("No other script users found!", "info")
    else
        local message = "Script Users (" .. #userList .. "):\n" .. table.concat(userList, "\n")
        showNotification(message, "info")
    end
end

-- UPDATE COMMAND
local function updateScript()
    showNotification("Updating to latest version...", "info")
    wait(0.5)
    
    -- Unexecute current version
    scriptActive = false
    
    -- Disable all features
    if commandStates.flying then disableFly() end
    if commandStates.supermanFly then disableSupermanFly() end
    if commandStates.noclip then disableNoclip() end
    if commandStates.float then disableFloat() end
    if commandStates.infiniteJump then disableInfiniteJump() end
    if commandStates.spinning then disableSpin() end
    if commandStates.invisible then makeVisible() end
    if commandStates.chatBypass then toggleChatBypass() end
    if commandStates.antiAfk then toggleAntiAfk() end
    
    -- Disconnect all connections
    for _, conn in pairs(activeConnections) do
        if conn then
            pcall(function()
                conn:Disconnect()
            end)
        end
    end
    
    -- Remove all overhead cards
    for _, card in pairs(allUserCards) do
        if card and card.Parent then
            pcall(function()
                card:Destroy()
            end)
        end
    end
    
    -- Remove attributes from character
    if character then
        character:SetAttribute(CONFIG.ScriptIdentifier, nil)
        character:SetAttribute("ExecutorInfo", nil)
        character:SetAttribute("DeviceInfo", nil)
    end
    
    -- Remove GUI
    if screenGui then
        screenGui:Destroy()
    end
    
    -- Clear globals
    commandStates = nil
    activeConnections = nil
    scriptUsers = nil
    allUserCards = nil
    
    -- Load new version
    wait(0.5)
    local success, err = pcall(function()
        loadstring(game:HttpGet(SCRIPT_URL))()
    end)
    
    if not success then
        warn("Update failed: " .. tostring(err))
    end
end

-- UNEXECUTE
local function unexecute()
    showNotification("Unexecuting script...", "info")
    wait(1)
    
    scriptActive = false
    
    -- Disable all features
    if commandStates.flying then disableFly() end
    if commandStates.supermanFly then disableSupermanFly() end
    if commandStates.noclip then disableNoclip() end
    if commandStates.float then disableFloat() end
    if commandStates.infiniteJump then disableInfiniteJump() end
    if commandStates.spinning then disableSpin() end
    if commandStates.invisible then makeVisible() end
    if commandStates.chatBypass then toggleChatBypass() end
    if commandStates.antiAfk then toggleAntiAfk() end
    
    -- Disconnect all connections
    for _, conn in pairs(activeConnections) do
        if conn then
            pcall(function()
                conn:Disconnect()
            end)
        end
    end
    
    -- Remove all overhead cards
    for _, card in pairs(allUserCards) do
        if card and card.Parent then
            pcall(function()
                card:Destroy()
            end)
        end
    end
    
    -- Remove identifier from all players
    for _, plr in pairs(Players:GetPlayers()) do
        if plr.Character then
            -- Remove attributes
            plr.Character:SetAttribute(CONFIG.ScriptIdentifier, nil)
            plr.Character:SetAttribute("ExecutorInfo", nil)
            plr.Character:SetAttribute("DeviceInfo", nil)
            
            local head = plr.Character:FindFirstChild("Head")
            if head then
                local userCard = head:FindFirstChild("UserCard")
                if userCard then
                    userCard:Destroy()
                end
            end
        end
    end
    
    -- Remove GUI
    if screenGui then
        screenGui:Destroy()
    end
    
    -- Clear globals
    commandStates = nil
    activeConnections = nil
    scriptUsers = nil
    allUserCards = nil
    
    print("$errated - Script unexecuted successfully")
end

-- Command Parser
local function executeCommand(commandText)
    if commandText:sub(1, 1) ~= CONFIG.CommandPrefix then return end
    
    local args = {}
    for word in commandText:gmatch("%S+") do
        table.insert(args, word)
    end
    
    if #args == 0 then return end
    
    local command = args[1]:sub(2):lower()
    
    -- Movement
    if command == "fly" then
        enableFly()
    elseif command == "unfly" then
        disableFly()
    elseif command == "flyspeed" then
        if #args < 2 then
            showNotification("Usage: !flyspeed [number]", "error")
        else
            local speed = tonumber(args[2])
            if speed then
                commandStates.flySpeed = speed
                showNotification("Fly speed set to " .. speed, "success")
            else
                showNotification("Invalid speed value!", "error")
            end
        end
    elseif command == "rsfly" then
        commandStates.flySpeed = 50
        showNotification("Fly speed reset to 50!", "success")
    elseif command == "smfly" or command == "superman" then
        enableSupermanFly()
    elseif command == "unsmfly" or command == "unsuperman" then
        disableSupermanFly()
    elseif command == "smspeed" then
        if #args < 2 then
            showNotification("Usage: !smspeed [number]", "error")
        else
            local speed = tonumber(args[2])
            if speed then
                commandStates.supermanSpeed = speed
                showNotification("Superman speed set to " .. speed, "success")
            else
                showNotification("Invalid speed value!", "error")
            end
        end
    elseif command == "rssm" then
        commandStates.supermanSpeed = 3
        showNotification("Superman speed reset to 3!", "success")
    elseif command == "noclip" or command == "clip" then
        enableNoclip()
    elseif command == "unnoclip" or command == "unclip" then
        disableNoclip()
    elseif command == "float" then
        enableFloat()
    elseif command == "unfloat" then
        disableFloat()
    elseif command == "infj" or command == "infinitejump" then
        enableInfiniteJump()
    elseif command == "uninfj" or command == "uninfinitejump" then
        disableInfiniteJump()
    
    -- Teleport
    elseif command == "tp" or command == "goto" then
        if #args < 2 then
            showNotification("Usage: !tp [username]", "error")
        else
            teleportToPlayer(args[2])
        end
    elseif command == "bring" then
        if #args < 2 then
            showNotification("Usage: !bring [username]", "error")
        else
            bringPlayer(args[2])
        end
    elseif command == "tptool" then
        createTpTool()
    
    -- Stats
    elseif command == "ws" or command == "walkspeed" then
        if #args < 2 then
            showNotification("Usage: !ws [number]", "error")
        else
            setWalkSpeed(args[2])
        end
    elseif command == "resetws" then
        resetWalkSpeed()
    elseif command == "jp" or command == "jumppower" then
        if #args < 2 then
            showNotification("Usage: !jp [number]", "error")
        else
            setJumpPower(args[2])
        end
    elseif command == "resetjp" then
        resetJumpPower()
    elseif command == "gravity" then
        if #args < 2 then
            showNotification("Usage: !gravity [number]", "error")
        else
            setGravity(args[2])
        end
    elseif command == "resetgravity" then
        resetGravity()
    
    -- Avatar
    elseif command == "char" then
        if #args < 2 then
            showNotification("Usage: !char [username]", "error")
        else
            loadCharacter(args[2])
        end
    elseif command == "invisible" then
        makeInvisible()
    elseif command == "visible" then
        makeVisible()
    
    -- Fun
    elseif command == "spin" then
        enableSpin()
    elseif command == "unspin" then
        disableSpin()
    elseif command == "spinspeed" then
        if #args < 2 then
            showNotification("Usage: !spinspeed [number]", "error")
        else
            local speed = tonumber(args[2])
            if speed then
                commandStates.spinSpeed = speed
                showNotification("Spin speed set to " .. speed, "success")
            else
                showNotification("Invalid speed value!", "error")
            end
        end
    
    -- Chat & Protection
    elseif command == "cb" or command == "chatbypass" then
        toggleChatBypass()
    elseif command == "antiafk" or command == "antiidle" then
        toggleAntiAfk()
    elseif command == "antivcban" or command == "antivcb" or command == "novcb" then
        toggleAntiVcBan()
    
    -- Server
    elseif command == "rejoin" or command == "rj" then
        rejoinServer()
    elseif command == "serverhop" or command == "shop" then
        serverHop()
    elseif command == "join" then
        if #args < 2 then
            showNotification("Usage: !join [username]", "error")
        else
            joinUser(args[2])
        end
    
    -- Utility
    elseif command == "update" or command == "updt" then
        updateScript()
    elseif command == "users" then
        listScriptUsers()
    elseif command == "unexecute" then
        unexecute()
    elseif command == "help" then
        if not mainFrame.Visible then
            mainFrame.Visible = true
            mainFrame.Size = UDim2.new(0, 0, 0, 0)
            smoothTween(mainFrame, {Size = UDim2.new(0, 750, 0, 600)}, 0.5)
        end
        showNotification("Command list opened!", "info")
    else
        showNotification("Unknown command: " .. command, "error")
    end
end

-- Input handling
commandInput.FocusLost:Connect(function(enterPressed)
    if enterPressed and commandInput.Text ~= "" then
        executeCommand(commandInput.Text)
        commandInput.Text = ""
        suggestionLabel.Text = ""
    end
end)

local function toggleMenu()
    mainFrame.Visible = not mainFrame.Visible
    
    if mainFrame.Visible then
        mainFrame.Size = UDim2.new(0, 0, 0, 0)
        smoothTween(mainFrame, {Size = UDim2.new(0, 750, 0, 600)}, 0.5)
        commandInput:CaptureFocus()
    else
        smoothTween(mainFrame, {Size = UDim2.new(0, 0, 0, 0)}, 0.4, function()
            mainFrame.Visible = false
            mainFrame.Size = UDim2.new(0, 750, 0, 600)
        end)
    end
end

closeButton.MouseButton1Click:Connect(toggleMenu)
toggleButton.MouseButton1Click:Connect(toggleMenu)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == CONFIG.ToggleKey then
        toggleMenu()
    end
end)

closeButton.MouseEnter:Connect(function()
    smoothTween(closeButton, {BackgroundColor3 = CONFIG.Colors.Primary}, 0.2)
end)
closeButton.MouseLeave:Connect(function()
    smoothTween(closeButton, {BackgroundColor3 = CONFIG.Colors.Background}, 0.2)
end)

-- Initialize
commandStates.originalWalkSpeed = humanoid.WalkSpeed
if humanoid.UseJumpPower then
    commandStates.originalJumpPower = humanoid.JumpPower
else
    commandStates.originalJumpPower = humanoid.JumpHeight * 3.5
end
commandStates.originalGravity = workspace.Gravity

markAsScriptUser()
monitorScriptUsers()

-- Character respawn handling
player.CharacterAdded:Connect(function(newChar)
    if not scriptActive then return end
    character = newChar
    humanoid = character:WaitForChild("Humanoid")
    markAsScriptUser()
    
    commandStates.originalWalkSpeed = humanoid.WalkSpeed
    if humanoid.UseJumpPower then
        commandStates.originalJumpPower = humanoid.JumpPower
    else
        commandStates.originalJumpPower = humanoid.JumpHeight * 3.5
    end
end)

-- Player added handling
Players.PlayerAdded:Connect(function(newPlayer)
    if not scriptActive then return end
    newPlayer.CharacterAdded:Connect(function()
        if not scriptActive then return end
        wait(1)
        if isScriptUser(newPlayer) then
            createUserCard(newPlayer)
        end
    end)
end)

-- Existing player handling
for _, existingPlayer in ipairs(Players:GetPlayers()) do
    if existingPlayer.Character then
        if isScriptUser(existingPlayer) then
            createUserCard(existingPlayer)
        end
    end
    
    existingPlayer.CharacterAdded:Connect(function()
        if not scriptActive then return end
        wait(1)
        if isScriptUser(existingPlayer) then
            createUserCard(existingPlayer)
        end
    end)
end

-- Auto-reexecution after teleport
if isAutoReexec then
    wait(2)
    showNotification("$errated auto-reexecuted!", "success")
else
    wait(1)
    showNotification("$errated executed!", "success")
end

print("═══════════════════════════════════════")
print("$errated Command Menu v5.0 - PROFESSIONAL")
print("User: " .. player.Name)
print("Executor: " .. EXECUTOR)
print("Device: " .. DEVICE)
print("Features: Full functionality + Auto-reexec")
print("Type !help for commands")
print("═══════════════════════════════════════")
